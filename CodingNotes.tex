\documentclass[10pt]{article}


%Define the listing package
\usepackage{listings} %code highlighter
\usepackage{color} %use color
\usepackage[hidelinks]{hyperref}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}


 
%Customize a bit the look
\lstset{ %
backgroundcolor=\color{white}, % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
basicstyle=\footnotesize, % the size of the fonts that are used for the code
breakatwhitespace=false, % sets if automatic breaks should only happen at whitespace
breaklines=true, % sets automatic line breaking
captionpos=b, % sets the caption-position to bottom
commentstyle=\color{mygreen}, % comment style
deletekeywords={...}, % if you want to delete keywords from the given language
escapeinside={\%*}{*)}, % if you want to add LaTeX within your code
extendedchars=true, % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
frame=single, % adds a frame around the code
keepspaces=true, % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
keywordstyle=\color{blue}, % keyword style
% language=Octave, % the language of the code
morekeywords={*,...}, % if you want to add more keywords to the set
numbers=left, % where to put the line-numbers; possible values are (none, left, right)
numbersep=5pt, % how far the line-numbers are from the code
numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
rulecolor=\color{black}, % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
showspaces=false, % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
showstringspaces=false, % underline spaces within strings only
showtabs=false, % show tabs within strings adding particular underscores
stepnumber=1, % the step between two line-numbers. If it's 1, each line will be numbered
stringstyle=\color{mymauve}, % string literal style
tabsize=2, % sets default tabsize to 2 spaces
title=\lstname % show the filename of files included with \lstinputlisting; also try caption instead of title
}
%END of listing package%
 
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
 
%define Javascript language
\lstdefinelanguage{JavaScript}{
keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, let, const, for, if, in, while, do, else, case, break},
keywordstyle=\color{blue}\bfseries,
ndkeywords={class, export, boolean, throw, implements, import, this},
ndkeywordstyle=\color{darkgray}\bfseries,
identifierstyle=\color{black},
sensitive=false,
comment=[l]{//},
morecomment=[s]{/*}{*/},
commentstyle=\color{purple}\ttfamily,
stringstyle=\color{red}\ttfamily,
morestring=[b]',
morestring=[b]"
}
 
\lstset{
language=JavaScript,
extendedchars=true,
basicstyle=\ttfamily,
showstringspaces=false,
showspaces=false,
numbers=left,
numberstyle=\footnotesize,
numbersep=9pt,
tabsize=2,
breaklines=true,
showtabs=false,
captionpos=b
}



















\title{Javascript Notes: Concepts, Algorithms, and Data Structures}
\author{Samuel Duval}


\begin{document}

%\date{}
\maketitle

\pagebreak

%\tableofcontents

%\section{Introduction}


Welcome to my notes on coding. In this document I'll keep track of basic Javascript concepts, algorithms, and perhaps some data structures as well. These notes are to help me formalize this information in my own brain. Pretty much everything is from the internet, attribution will be given in some cases, but generally for the sake of brevity and since all concepts are basic it will be omitted. 

\tableofcontents

\pagebreak

\section{Basic Javascript Concepts}

\medskip %START OF SLICE
\subsection{Array.prototype.slice()}
\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice}

\begin{itemize}
	\item slice() returns a shallow copy of a portion of an array
	\item array.slice(startIndex, endIndex)
	\item slice() does not modify the array
	\item without arguments slice() will automatically be slice(0, endIndex)
	
\begin{lstlisting}[title=Example slice(), captionpos=t]
let fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']

let citrus = fruits.slice(1, 3)
// citrus contains ['Orange','Lemon']

// fruits STILL contains ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']

\end{lstlisting}
\end{itemize}
\medskip %END OF SLICE


\pagebreak
\medskip %START OF SORT
\subsection{Array.prototype.sort()}
\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort}	

\begin{itemize}
	\item sort() returns the same array in sorted order
	\item default order is ascending, done by converting everything to a string then comparing the UTF-16 code unit values. So it does not naturally work for numbers as expected.
	\item sort() modifies the the array
	
\begin{lstlisting}[title=Example sort() for integers, captionpos=t]
const numbers = [4, 2, 5, 1, 3];

numbers.sort((a, b) => a - b);

console.log(numbers);
// [1, 2, 3, 4, 5]
\end{lstlisting}
\end{itemize}
\medskip %END OF SORT


\medskip %START OF JOIN
\pagebreak
\subsection{Array.prototype.join()}
\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join}

\begin{itemize}
	\item join() returns a new STRING by concatenating all elements in an ARRAY 
	\item items should be seperated by commas (,) (or specified seperator string), if only one item then that item will be returned without using the seperator.

	
\begin{lstlisting}[title=Example join(), captionpos=t]
const elements = ['Fire', 'Air', 'Water'];

console.log(elements.join());
// expected output: "Fire,Air,Water"

console.log(elements.join(''));
// expected output: "FireAirWater"

console.log(elements.join('-'));
// expected output: "Fire-Air-Water"
\end{lstlisting}
\end{itemize}
\medskip %END OF JOIN


\medskip %START OF INDEXOF
\pagebreak
\subsection{Array.prototype.indexOf()}
\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf}

\begin{itemize}
	\item indexOf() returns the first index at which a given element can be found in an array or -1 if not found
	\item good for finding the index of first appearance of something. If you want last use lastIndexOf()
	
\begin{lstlisting}[title=Example indexOf(), captionpos=t]
const names = ['sam', 'bill', 'steve', 'matt']

const idx = names.indexOf('sam')
names[idx] = 'replaced-sam'

console.log(names)
//[ 'replaced-sam', 'bill', 'steve', 'matt' ]
\end{lstlisting}
\end{itemize}
\medskip %END OF INDEXOF


\medskip %START OF REDUCE
\pagebreak
\subsection{Array.prototype.reduce()}
\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce}

\begin{itemize}
	\item reduce() passes a callback function on each item in the array and has a second parameter for storing current value
	\item reduce((callback, currentValue) $\rightarrow$ callback, currentValue) 
\end{itemize}

	
\begin{lstlisting}[title=Example reduce(), captionpos=t]
const array = [1,2,3,4,5]

let reduceExample = array.reduce((callback, currentValue) => callback + currentValue)

console.log(reduceExample)
//output: 15
\end{lstlisting}
\medskip %END OF REDUCE


\medskip %START OF SPLIT
\pagebreak
\subsection{String.prototype.split()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split}

\begin{itemize}
	\item takes a string and splits it into parts and returns it as an array
	\item split(), split(separator), split(separator, limit) 
	\item can pass in a value(separator) and it will decide where the string will be split
	\item can also take regular expressions ex. too many commas split(/,+/) may help resolve
\end{itemize}

	
\begin{lstlisting}[title=Example split(), captionpos=t]
const splitString = 'Hello,my,name,is,Sam'

let split = splitString.split(',')

console.log(split) 
//[ 'Hello', 'my', 'name', 'is', 'Sam' ]
\end{lstlisting}
\medskip %END OF SPLIT


\medskip %START OF FILL
\pagebreak
\subsection{Array.prototype.fill()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill}

\begin{itemize}
	\item Modifies an array with the value given in fill() 
	\item fill(0) by default, fill(value, start, end)
	\item useful for filling an array with numbers (0 seems common followed by other operations)
\end{itemize}

	
\begin{lstlisting}[title=Example fill(), captionpos=t]
const fillArray = [0,1,2,3,4,5]
const fillArray2 = [0,1,2,3,4,5]

fillArray.fill(0)
//[ 0, 0, 0, 0, 0, 0 ]

fillArray2.fill(0,3,5)
//[ 0, 1, 2, 0, 0, 5 ]
\end{lstlisting}
\medskip %END OF FILL


\medskip %START OF MAP
\pagebreak
\subsection{map()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map}

\begin{itemize}
	\item Executes a function on all elements of an array and returns a new array 
	\item Does not change original array
	\item map(callback)
	\item Can even return new array of objects
	\item Useful for pulling specific parts out of an array or for manipulating an entire array (ex. to find total value of objects within)
\end{itemize}

	
\begin{lstlisting}[title=Example simple map() multiplying all elements by two, captionpos=t]
const numbers = [1,2,3,4,5];

let mapNumbers = numbers.map(nums => (nums * 2))
//[ 2, 4, 6, 8, 10 ]
\end{lstlisting}

\begin{lstlisting}[title=Example map() Number constructor turning string numbers into regular integers, captionpos=t]
const stringNumbers = ['1', '2', '3', '4', '5']

const regNumbers = stringNumbers.map(Number)
// [ 1, 2, 3, 4, 5 ]
\end{lstlisting}

\begin{lstlisting}[title=Example simple map() to manipulate objects within array, captionpos=t]
const products = [
    {
        name: 'laptop',
        price: 1500,
        count: 5
    },
    {
        name: 'desktop',
        price: 2000,
        count: 10
    },
    {
        name: 'phone',
        price: 1000,
        count: 100
    }
];

const totalProductValue = products.map(item => item.price * item.count);
//[ 7500, 20000, 100000 ]

const totalProductValueObject = products.map(item => ({
    name: item.name,
    totalValue: item.price * item.count
}));
// [
//     { name: 'laptop', totalValue: 7500 },
//     { name: 'desktop', totalValue: 20000 },
//     { name: 'phone', totalValue: 100000 }
// ]
\end{lstlisting}
\medskip %END OF MAP


\medskip %START OF PUSH
\pagebreak
\subsection{Array.prototype.push()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push}

\begin{itemize}
	\item push() add ones or more elements to the end of an array
	\item push(x,y,z,1,2,3,etc.) can have as many parameters as desired
	\item push returns the new array length (for updated original array simply return that iteself)
\end{itemize}

	
\begin{lstlisting}[title=Example push(), captionpos=t]
const numbers = [1,2,3,4,5]

numbers.push(6)
//[ 1, 2, 3, 4, 5, 6 ]

numbers.push(6,7,8,9,10)
//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

//note: if done in order above it would be 
//[1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10]

const total = numbers.push(6,7,8,9,10)
//10
//note: would be 16 if done as above 
\end{lstlisting}
\medskip %END OF PUSH



\medskip %START OF SPLICE
\pagebreak
\subsection{Array.prototype.splice()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice}

\begin{itemize}
	\item splice() modifies an array by removing and/or replacing existing elements from it
	\item splice(startIndex, removalCount, newElementsAdded)
\end{itemize}

	
\begin{lstlisting}[title=Example splice(), captionpos=t]
const numbers = [1,2,3,4,5];

numbers.splice(2,3)
//[ 1, 2 ]

let deleted = numbers.splice(2,3)
//[ 3, 4, 5 ]

numbers.splice(2,3,6,9)
//[ 1, 2, 6, 9 ]

numbers.splice(2,0,6,9)
//[ 1, 2, 6, 9, 3, 4, 5 ]
\end{lstlisting}
\medskip %END OF SPLICE



\medskip %START OF XOR
\pagebreak
\subsection{Bitwise XOR (\textasciicircum)}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR}

\begin{itemize}
	\item XOR (\textasciicircum) returns a 1 if the other corresponding bit is different
\end{itemize}

\begin{lstlisting}[title= XOR (\textasciicircum) rules, captionpos=t]
//0 & 0 = 0 
//0 & 1 = 1
//1 & 1 = 0 
\end{lstlisting}

\begin{lstlisting}[title=Example XOR (\textasciicircum), captionpos=t]
const a = 5;        
// 00000000000000000000000000000101
const b = 3;        
// 00000000000000000000000000000011

console.log(a ^ b); 
// 00000000000000000000000000000110
// expected output: 6
\end{lstlisting}
\medskip %END OF XOR


\medskip %START OF CHARCODEAT
\pagebreak
\subsection{String.prototype.charCodeAt()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt}

\begin{itemize}
	\item Returns the unicode integer of the character in a string representing the UTF-16 code unit of the given index.
\end{itemize}

\begin{lstlisting}[title=Example charCodeAt(), captionpos=t]
const sentence = 'My name is Sam';

const index = 4;
const otherLocation = 1;

console.log(`The character code ${sentence.charCodeAt(index)} is equal to ${sentence.charAt(index)}`);
// "The character code 97 is equal to a"

console.log(`The character code ${sentence.charCodeAt(otherLocation)} is equal to ${sentence.charAt(otherLocation)}`);
//"The character code 121 is equal to y"
\end{lstlisting}
\medskip %END OF CHARCODEAT




\medskip %START OF FROMCHARCODE
\pagebreak
\subsection{String.fromCharCode()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode}

\begin{itemize}
	\item The static String.fromCharCode() method returns a string created from the specified sequence of UTF-16 code units.
\end{itemize}

\begin{lstlisting}[title=Example fromCharCode(), captionpos=t]
String.fromCharCode(65, 66, 67);   
// returns "ABC"
\end{lstlisting}
\medskip %END OF FROMCHARCODE



\medskip %START OF SOME()
\pagebreak
\subsection{Array.prototype.some()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some}

\begin{itemize}
	\item Executes a given function and returns true if at least one element in array provides a truthy value. 
	\item If no item in array is true, it will provide false
\end{itemize}

\begin{lstlisting}[title=Example some(), captionpos=t]
const numbers = [1,2,3,4,5]

const res = numbers.some(greaterThanThree)
//true

function greaterThanThree(num) {
    return num > 3;
}
\end{lstlisting}
\medskip %END OF SOME()


\medskip %START OF EVERY()
\pagebreak
\subsection{Array.prototype.every()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every}

\begin{itemize}
	\item Executes a given function on all items in an array and return true only if ALL items are truthy
	\item If any item in the array returns a falsy value, it will automatically return false
\end{itemize}

\begin{lstlisting}[title=Example every(), captionpos=t]
const numbers = [1,2,3,4,5,-1]

const res = numbers.every(isPositive)
//false

function isPositive(num) {
    return num > 0;
}
\end{lstlisting}
\medskip %END OF EVERY()




\medskip %START OF INCLUDES()
\pagebreak
\subsection{Array.prototype.includes()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes}

\begin{itemize}
	\item Checks in an element is included in an array
	\item If the item is included it will return true
	\item If the item is not included it will return false
\end{itemize}

\begin{lstlisting}[title=Example includes(), captionpos=t]
const names = ['Sam', 'Gabe', 'Troy']

const res = names.includes('Sam')
// true
const res = names.includes('Bill')
// false
\end{lstlisting}
\medskip %END OF INCLUDES()


\medskip %START OF FIND()
\pagebreak
\subsection{Array.prototype.find()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find}

\begin{itemize}
	\item Returns the first element in an array for which the callback has a truthy value
	\item If object will return the whole object (or you can return a part of an object)
	\item if nothing is found it will return undefined
\end{itemize}

\begin{lstlisting}[title=Example find(), captionpos=t]
const names = ['Sam', 'Gabe', 'Troy']

const namedPerson = names.find(findName)
//Gabe

function findName(name) {
    return name === 'Gabe'
}
\end{lstlisting}

\begin{lstlisting}[title=Example find() with objects, captionpos=t]
const inventory = [
    {name: 'apples', quantity: 2},
    {name: 'bananas', quantity: 0},
    {name: 'cherries', quantity: 5}
  ];
  
  const result = inventory.find( ({ name }) => name === 'cherries' );
  //{ name: 'cherries', quantity: 5 }
  const result = inventory.find( ({ name }) => name === 'cherries' ).quantity;
  //5
\end{lstlisting}
\medskip %END OF FIND()



\medskip %START OF MATH.MAX.MIN.ABS()
\pagebreak
\subsection{Math.max(), Math.min(), Math.abs()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max}

\medskip

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min}

\medskip

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/abs}


\begin{itemize}
	\item Math.max() 
	\item Returns highest value in list
	\item Math.min()
	\item Returns lowest value in list 
	\item Math.abs()
	\item Returns absolute value of a number (distance from zero) 
\end{itemize}

\begin{lstlisting}[title=Example Math.max(), captionpos=t]
console.log(Math.max(1, 3, 2));
// expected output: 3

console.log(Math.max(-1, -3, -2));
// expected output: -1
\end{lstlisting}


\begin{lstlisting}[title=Example Math.min(), captionpos=t]
console.log(Math.min(2, 3, 1));
// expected output: 1

console.log(Math.min(-2, -3, -1));
// expected output: -3
\end{lstlisting}


\begin{lstlisting}[title=Example Math.abs(), captionpos=t]
function difference(a, b) {
  return Math.abs(a - b);
}

console.log(difference(3, 5));
// expected output: 2

console.log(difference(5, 3));
// expected output: 2
\end{lstlisting}
\medskip %END OF MATH.MAX.MIN.ABS()




\medskip %START OF PARSEINT()
\pagebreak
\subsection{parseInt() \& parseFloat()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt}

\medskip

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseFloat}


\begin{itemize}
	\item parseInt() take a float or string and parses the integer out of it
	\item Will go from start to end of the first integer it sees (if it sees words, space, or any non-number it will stop) 
	\item parseFloat() will do the same except it will run through the first period (.) and stop at the next period / non-number
	\item These don't work if the int / float isn't at the start of the string
	\item Note: parseInt(string, radix) careful of radix when passing values to parseInt
\end{itemize}

\begin{lstlisting}[title=Example parseInt(), captionpos=t]
let testString = '1337demo' 
let parseIntDemo = parseInt(testString)
//1337
\end{lstlisting}

\begin{lstlisting}[title=Example parseFloat(), captionpos=t]
let testStringTwo = '1337.37.37demo'
let parseFloatDemo = parseFloat(testStringTwo)
//1337.37
\end{lstlisting}

\begin{lstlisting}[title=Example parseInt() without numbers at start, captionpos=t]
let testString = 'doesnotwork1337.37.37demo'
let parseIntDemo = parseInt(testString)
//NaN
\end{lstlisting}

\begin{lstlisting}[title=Example parseInt() with radix 16, captionpos=t]
console.log(roughScale(' 0xF', 16));
// expected output: 1500
\end{lstlisting}

\medskip %END OF PARSEINT()



\medskip %START OF AND & OR ()
\pagebreak
\subsection{Logical (and \&\&) and (or	$\Vert$) }

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR}

\medskip

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND}


\begin{itemize}
	\item The logical AND (\&\&) operator (logical conjunction) for a set of boolean operands will be true if and only if all the operands are true. Otherwise it will be false.
	\item More generally, the operator returns the value of the first falsy operand encountered when evaluating from left to right, or the value of the last operand if they are all truthy.
	\item The logical OR ($\Vert$) operator (logical disjunction) for a set of operands is true if and only if one or more of its operands is true.
	\item the $\Vert$ operator actually returns the value of one of the specified operands, so if this operator is used with non-Boolean values, it will return a non-Boolean value.
\end{itemize}

\begin{lstlisting}[title=Example Logical AND \&\&, captionpos=t]
const a = 3;
const b = -2;

console.log(a > 0 && b > 0);
// expected output: false
\end{lstlisting}

\begin{lstlisting}[title=Example Logical AND \&\&, captionpos=t]
result = 2 && 0;      
// result is assigned 0
result = 'foo' && 4;  
// result is assigned 4
\end{lstlisting}

\begin{lstlisting}[title=Example Logical OR $\Vert$, captionpos=t]
const a = 3;
const b = -2;

console.log(a > 0 || b > 0);
// expected output: true
\end{lstlisting}

\begin{lstlisting}[title=Example Logical OR $\Vert$, captionpos=t]
o3 = true  || false      
// t || f returns true
o4 = false || (3 == 4)   
// f || f returns false
o5 = 'Cat' || 'Dog'     
// t || t returns "Cat"
\end{lstlisting}

\medskip %END OF OF AND & OR ()





\medskip %START OF SET() CONSTRUCTOR
\pagebreak
\subsection{Set() constructor}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/Set}

\begin{itemize}
	\item The Set constructor lets you create Set objects that store unique values of any type, whether primitive values or object references.
\end{itemize}

\begin{lstlisting}[title=Example set1 = new Set(), captionpos=t]
const set1 = new Set([1, 2, 3, 4, 5]);

console.log(set1.has(1));
// expected output: true

console.log(set1.has(5));
// expected output: true

console.log(set1.has(6));
// expected output: false
\end{lstlisting}

\begin{lstlisting}[title=Example using Set() object, captionpos=t]
let mySet = new Set()

mySet.add(1)           
// Set [ 1 ]
mySet.add(5)          
// Set [ 1, 5 ]
mySet.add(5)           
// Set [ 1, 5 ]
mySet.add('some text') // Set [ 1, 5, 'some text' ]
let o = {a: 1, b: 2}
mySet.add(o)
\end{lstlisting}

\medskip %END OF SET() CONSTRUCTOR








\medskip %START OF CHARAT()
\pagebreak
\subsection{String.prototype.charAt()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charAt}

\begin{itemize}
	\item The String object's charAt() method returns a new string consisting of the single UTF-16 code unit located at the specified offset into the string.
	\item charAt(index)
\end{itemize}

\begin{lstlisting}[title=Example charAt(), captionpos=t]
const sentence = 'The quick brown fox jumps over the lazy dog.';

const index = 4;

console.log(`The character at index ${index} is ${sentence.charAt(index)}`);
// expected output: "The character at index 4 is q"
\end{lstlisting}

\medskip %END OF CHARAT()








\medskip %START OF FOROF()
\pagebreak
\subsection{for...of}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of}

\begin{itemize}
	\item The for...of statement creates a loop iterating over iterable objects, including: built-in String, Array, array-like objects (e.g., arguments or NodeList), TypedArray, Map, Set, and user-defined iterables. It invokes a custom iteration hook with statements to be executed for the value of each distinct property of the object.
\end{itemize}

\begin{lstlisting}[title=Example for...of, captionpos=t]
const array1 = ['a', 'b', 'c'];

for (const element of array1) {
  console.log(element);
}

// expected output: "a"
// expected output: "b"
// expected output: "c"
\end{lstlisting}

\begin{lstlisting}[title=Example for...of, captionpos=t]
for (variable of iterable) {
  statement
}
\end{lstlisting}
\medskip %END OF FOROF()









\medskip %START OF FORIN()
\pagebreak
\subsection{for...in}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in}

\begin{itemize}
	\item The for...in statement iterates over all enumerable properties of an object that are keyed by strings (ignoring ones keyed by Symbols), including inherited enumerable properties.
\end{itemize}

\begin{lstlisting}[title=Example for...in, captionpos=t]
const object = { a: 1, b: 2, c: 3 };

for (const property in object) {
  console.log(`${property}: ${object[property]}`);
}

// expected output:
// "a: 1"
// "b: 2"
// "c: 3"
\end{lstlisting}

\begin{lstlisting}[title=Example for...in, captionpos=t]
for (const variable in object) {
  statement
}
\end{lstlisting}
\medskip %END OF FORIN()













\medskip %START OF TERNARY
\pagebreak
\subsection{Conditional (ternary) operator}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator}

\begin{itemize}
	\item The conditional (ternary) operator is the only JavaScript operator that takes three operands
	\item A condition followed by a question mark (?), then an expression to execute if the condition is truthy followed by a colon (:), and finally the expression to execute if the condition is falsy.
	\item This operator is frequently used as an alternative to an if...else statement.
	\item condition ? exprIfTrue : exprIfFalse
\end{itemize}

\begin{lstlisting}[title=Example ternary operator, captionpos=t]
function getFee(isMember) {
  return (isMember ? '$2.00' : '$10.00');
}

console.log(getFee(true));
// expected output: "$2.00"

console.log(getFee(false));
// expected output: "$10.00"

console.log(getFee(null));
// expected output: "$10.00"
\end{lstlisting}


\begin{lstlisting}[title=Example ternary operator, captionpos=t]
const age = 26;
const beverage = age >= 21 ? "Beer" : "Juice";
console.log(beverage); // "Beer"
\end{lstlisting}
\medskip %END OF TERNARY














\medskip %START OF GET()
\pagebreak
\subsection{Map.prototype.get()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get}

\begin{itemize}
	\item The get() method returns a specified element from a Map object. 
	\item If the value that is associated to the provided key is an object, then you will get a reference to that object and any change made to that object will effectively modify it inside the Map object.
	\item get(key)
\end{itemize}

\begin{lstlisting}[title=Example Map.prototype.get(), captionpos=t]
const map1 = new Map();
map1.set('bar', 'foo');

console.log(map1.get('bar'));
// expected output: "foo"

console.log(map1.get('baz'));
// expected output: undefined
\end{lstlisting}


\begin{lstlisting}[title=Example get(), captionpos=t]
const arr = [];
const myMap = new Map();

myMap.set('bar', arr);
myMap.get('bar').push('foo');

console.log(arr); 
// ["foo"]
console.log(myMap.get('bar')); 
// ["foo"]
\end{lstlisting}
\medskip %END OF GET()





\medskip %START OF HAS()
\pagebreak
\subsection{Map.prototype.has()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has}

\begin{itemize}
	\item The has() method returns a boolean indicating whether an element with the specified key exists or not.
	\item has(key)

\end{itemize}

\begin{lstlisting}[title=Example Map.prototype.has(), captionpos=t]
const map1 = new Map();
map1.set('bar', 'foo');

console.log(map1.has('bar'));
// expected output: true

console.log(map1.has('baz'));
// expected output: false
\end{lstlisting}


\begin{lstlisting}[title=Example has(), captionpos=t]
let myMap = new Map()
myMap.set('bar', "foo")

myMap.has('bar')   
// returns true
myMap.has('baz')   
// returns false
\end{lstlisting}
\medskip %END OF HAS()







\medskip %START OF SET
\pagebreak
\subsection{Set}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set}

\begin{itemize}
	\item The Set object lets you store unique values of any type, whether primitive values or object references.	
	\item Set objects are collections of values. A value in the Set may only occur once; it is unique in the Set's collection.
	\item You can iterate through the elements of a set in insertion order. The insertion order corresponds to the order in which each element was inserted into the set by the add()

\end{itemize}

\begin{lstlisting}[title=Example Set 0bject, captionpos=t]
const mySet1 = new Set()

mySet1.add(1)           // Set [ 1 ]
mySet1.add(5)           // Set [ 1, 5 ]
mySet1.add(5)           // Set [ 1, 5 ]
mySet1.add('some text') // Set [ 1, 5, 'some text' ]
const o = {a: 1, b: 2}
mySet1.add(o)

mySet1.add({a: 1, b: 2})   // o is referencing a different object, so this is okay

mySet1.has(1)              // true
mySet1.has(3)              // false, since 3 has not been added to the set
mySet1.has(5)              // true
mySet1.has(Math.sqrt(25))  // true
mySet1.has('Some Text'.toLowerCase()) // true
mySet1.has(o)       // true

mySet1.size         // 5

mySet1.delete(5)    // removes 5 from the set
mySet1.has(5)       // false, 5 has been removed

mySet1.size         // 4, since we just removed one value

mySet1.add(5)       // Set [1, 'some text', {...}, {...}, 5] - a previously deleted item will be added as a new item, it will not retain its original position before deletion

console.log(mySet1)


\end{lstlisting}


\begin{lstlisting}[title=Example remove duplicate elements from array, captionpos=t]
// Use to remove duplicate elements from the array

const numbers = [2,3,4,4,2,3,3,4,4,5,5,6,6,7,5,32,3,4,5]

console.log([...new Set(numbers)])

// [2, 3, 4, 5, 6, 7, 32]
\end{lstlisting}


\begin{lstlisting}[title=Example relationship with array, captionpos=t]
const myArray = ['value1', 'value2', 'value3'];

// Use the regular Set constructor to transform an Array into a Set
const mySet = new Set(myArray);

mySet.has('value1')     // returns true

// Use the spread operator to transform a set into an Array.
console.log([...mySet]); // Will show you exactly the same Array as myArray
\end{lstlisting}



\begin{lstlisting}[title=Example relationship with string, captionpos=t]
const text = 'India';

const mySet = new Set(text);  // Set(5) {'I', 'n', 'd', 'i', 'a'}
mySet.size  // 5

//case sensitive & duplicate omission
new Set("Firefox")  // Set(7) { "F", "i", "r", "e", "f", "o", "x" }
new Set("firefox")  // Set(6) { "f", "i", "r", "e", "o", "x" }
\end{lstlisting}

\medskip %END OF SET()






\medskip %START OF toString()
\pagebreak
\subsection{Object.prototype.toString()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString}

\begin{itemize}
	\item The toString() method returns a string representing the object.
	\item toString()
\end{itemize}

\begin{lstlisting}[title=Example toString(), captionpos=t]
function Dog(name) {
  this.name = name;
}

const dog1 = new Dog('Gabby');

Dog.prototype.toString = function dogToString() {
  return `${this.name}`;
};

console.log(dog1.toString());
// expected output: "Gabby"
\end{lstlisting}


\begin{lstlisting}[title=Example toString(), captionpos=t]
const arr = [1, 2, 3];

arr.toString() 
// "1,2,3"
Object.prototype.toString.call(arr) 
// "[object Array]"
\end{lstlisting}

\medskip %END OF toString()









\medskip %START OF replace()
\pagebreak
\subsection{String.prototype.replace()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace}

\begin{itemize}
	\item The replace() method returns a new string with some or all matches of a pattern replaced by a replacement. 
	\item  The pattern can be a string or a RegExp, and the replacement can be a string or a function called for each match.
	\item If pattern is a string, only the first occurrence will be replaced.
	\item The original string is left unchanged.
	\item replace(substr, newSubstr)

\end{itemize}

\begin{lstlisting}[title=Example replace(), captionpos=t]
const p = 'The quick brown fox jumps over the lazy dog. If the dog reacted, was it really lazy?';

console.log(p.replace('dog', 'monkey'));
// expected output: "The quick brown fox jumps over the lazy monkey. If the dog reacted, was it really lazy?"

const regex = /Dog/gi;
console.log(p.replace(regex, 'ferret'));
// expected output: "The quick brown fox jumps over the lazy ferret. If the ferret reacted, was it really lazy?"

const regex = /Dog/i;
console.log(p.replace(regex, 'ferret'));
// expected output: "The quick brown fox jumps over the lazy ferret. If the dog reacted, was it really lazy?"
\end{lstlisting}

\medskip %END OF replace()









\medskip %START OF add()
\pagebreak
\subsection{Set.prototype.add()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/add}

\begin{itemize}
	\item The add() method inserts a new element with a specified value in to a Set object
	\item  Only works if  if there isn't an element with the same value already in the Set.
	\item add(value)

\end{itemize}

\begin{lstlisting}[title=Example add(), captionpos=t]
const set1 = new Set();

set1.add(42);
set1.add(42);
set1.add(13);

for (const item of set1) {
  console.log(item);
  // expected output: 42
  // expected output: 13
}
\end{lstlisting}

\begin{lstlisting}[title=Example add(), captionpos=t]
const mySet = new Set();

mySet.add(1);
mySet.add(5).add('some text'); // chainable

console.log(mySet);
// Set [1, 5, "some text"]
\end{lstlisting}

\medskip %END OF add()








\medskip %START OF unshift()
\pagebreak
\subsection{Array.prototype.unshift()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift}

\begin{itemize}
	\item The unshift() method adds one or more elements to the beginning of an array and returns the new length of the array.
	\item unshift(element0)
	\item unshift(element0, element1)
\end{itemize}

\begin{lstlisting}[title=Examples using unshift(), captionpos=t]
const arr = [1, 2]

arr.unshift(0)               
// result of the call is 3, which is the new array length
// arr is [0, 1, 2]

arr.unshift(-2, -1)          
// the new array length is 5
// arr is [-2, -1, 0, 1, 2]

arr.unshift([-4, -3])        
// the new array length is 6
// arr is [[-4, -3], -2, -1, 0, 1, 2]

arr.unshift([-7, -6], [-5])  
// the new array length is 8
// arr is [ [-7, -6], [-5], [-4, -3], -2, -1, 0, 1, 2 ]
\end{lstlisting}



\medskip %END OF unshift()











\medskip %START OF size()
\pagebreak
\subsection{Set.prototype.size}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/size}

\begin{itemize}
	\item The size accessor property returns the number of (unique) elements in a Set object.
	\item The value of size is an integer representing how many entries the Set object has.
	\item A set accessor function for size is undefined; you cannot change this property.
	\item set.size()
\end{itemize}

\begin{lstlisting}[title=Examples using size(), captionpos=t]
const mySet = new Set();
mySet.add(1);
mySet.add(5);
mySet.add('some text')

mySet.size; 
// 3
\end{lstlisting}

\medskip %END OF size()








\medskip %START OF setDELETE()
\pagebreak
\subsection{Set.prototype.delete()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/delete}

\begin{itemize}
	\item The delete() method removes a specified value from a Set object, if it is in the set.
	\item delete(value)
	\item Returns true if value was already in Set; otherwise false.
\end{itemize}

\begin{lstlisting}[title=Examples using delete(), captionpos=t]
const mySet = new Set();
mySet.add('foo');

mySet.delete('bar'); 
// Returns false. No "bar" element found to be deleted.
mySet.delete('foo');
// Returns true. Successfully removed.

mySet.has('foo');    
// Returns false. The "foo" element is no longer present.
\end{lstlisting}

\begin{lstlisting}[title=Examples using delete(), captionpos=t]
const setObj = new Set();   
// Create a new set.

setObj.add({x: 10, y: 20}); 
// Add object in the set.

setObj.add({x: 20, y: 30}); 
// Add object in the set.

// Delete any point with `x > 10`.
setObj.forEach(function(point){
  if (point.x > 10){
    setObj.delete(point)
  }
})
\end{lstlisting}

\medskip %END OF setDELETE()









\medskip %START OF Delete operator()
\pagebreak
\subsection{delete operator}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete}

\begin{itemize}
	\item The JavaScript delete operator removes a property from an object; if no more references to the same property are held, it is eventually released automatically.
	\item delete expression
	\item true for all cases except when the property is an Object.hasOwn non-configurable property, in which case, false is returned in non-strict mode.
\end{itemize}

\begin{lstlisting}[title=Example using delete operator, captionpos=t]
const Employee = {
  firstname: 'John',
  lastname: 'Doe'
};

console.log(Employee.firstname);
// expected output: "John"

delete Employee.firstname;

console.log(Employee.firstname);
// expected output: undefined
\end{lstlisting}

\begin{lstlisting}[title=Example using delete operator, captionpos=t]
const trees = ['redwood', 'bay', 'cedar', 'oak', 'maple'];
delete trees[3];
console.log(3 in trees); // false
\end{lstlisting}

\medskip %END OF  DELETE OPERATOR()






\medskip %START OF reverse()
\pagebreak
\subsection{Array.prototype.reverse()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse}

\begin{itemize}
	\item The reverse() method reverses an array in place. The first array element becomes the last, and the last array element becomes the first.

	\item reverse()
	\item return the reversed array
\end{itemize}

\begin{lstlisting}[title=Example using reverse(), captionpos=t]
const array1 = ['one', 'two', 'three'];
console.log('array1:', array1);
// expected output: "array1:" Array ["one", "two", "three"]

const reversed = array1.reverse();
console.log('reversed:', reversed);
// expected output: "reversed:" Array ["three", "two", "one"]

// Careful: reverse is destructive -- it changes the original array.
console.log('array1:', array1);
// expected output: "array1:" Array ["three", "two", "one"]

\end{lstlisting}

\begin{lstlisting}[title=Example using reverse() with array, captionpos=t]
const items = [1, 2, 3];
console.log(items);
// [1, 2, 3]

items.reverse();
console.log(items); ]
// [3, 2, 1]
\end{lstlisting}

\begin{lstlisting}[title=Example using reverse() in array like object, captionpos=t]
const obj = {0: 1, 1: 2, 2: 3, length: 3};
console.log(obj); 
// {0: 1, 1: 2, 2: 3, length: 3}

Array.prototype.reverse.call(obj); 
//same syntax for using apply()
console.log(obj); 
// {0: 3, 1: 2, 2: 1, length: 3}
\end{lstlisting}
\medskip %END OF  reverse()










\medskip %START OF Array() constructor
\pagebreak
\subsection{Array() constructor}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Array}

\begin{itemize}
	\item The Array() constructor is used to create Array objects.
\end{itemize}

\begin{lstlisting}[title=Example Array() constructor, captionpos=t]
// literal constructor
[element0, element1, ..., elementN]

// construct from elements
new Array(element0, element1, ..., elementN)

// construct from array length
new Array(arrayLength)
\end{lstlisting}

\begin{lstlisting}[title=Example using literal notation, captionpos=t]
let fruits = ['Apple', 'Banana'];

console.log(fruits.length); 
// 2
console.log(fruits[0]);     
// "Apple"
\end{lstlisting}

\medskip %END OF  Array() constructor







\medskip %START OF Math.trunc() 
\pagebreak
\subsection{Math.trunc()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Array}

\begin{itemize}
	\item The Math.trunc() function returns the integer part of a number by removing any fractional digits.
	\item Math.trunc(x)
\end{itemize}

\begin{lstlisting}[title=Example Math.trunc(), captionpos=t]
console.log(Math.trunc(13.37));
// expected output: 13

console.log(Math.trunc(42.84));
// expected output: 42

console.log(Math.trunc(0.123));
// expected output: 0

console.log(Math.trunc(-0.123));
// expected output: -0
\end{lstlisting}

\begin{lstlisting}[title=Example Math.trunc(), captionpos=t]
Math.trunc(13.37);    // 13
Math.trunc(42.84);    // 42
Math.trunc(0.123);    //  0
Math.trunc(-0.123);   // -0
Math.trunc('-1.123'); // -1
Math.trunc(NaN);      // NaN
Math.trunc('foo');    // NaN
Math.trunc();         // NaN
\end{lstlisting}
\medskip %END OF  Math.trunc() 










\medskip %START OF continue 
\pagebreak
\subsection{continue}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/continue}

\begin{itemize}
	\item The continue statement terminates execution of the statements in the current iteration of the current or labeled loop, and continues execution of the loop with the next iteration.
	\item continue [label];
	\item In a while loop, it jumps back to the condition.
	\item In a for loop, it jumps to the update expression.
\end{itemize}

\begin{lstlisting}[title=Example continue, captionpos=t]
let text = '';

for (let i = 0; i < 10; i++) {
  if (i === 3) {
    continue;
  }
  text = text + i;
}

console.log(text);
// expected output: "012456789"

\end{lstlisting}

\begin{lstlisting}[title=Example continue and label, captionpos=t]
let i = 0;
let j = 8;

checkiandj: while (i < 4) {
  console.log('i: ' + i);
  i += 1;

  checkj: while (j > 4) {
    console.log('j: ' + j);
    j -= 1;

    if ((j % 2) == 0)
      continue checkj;
    console.log(j + ' is odd.');
  }
  console.log('i = ' + i);
  console.log('j = ' + j);
}
\end{lstlisting}

\begin{lstlisting}[title=Example output continue and label, captionpos=t]
i: 0

// start checkj
j: 8
7 is odd.
j: 7
j: 6
5 is odd.
j: 5
// end checkj

i = 1
j = 4

i: 1
i = 2
j = 4

i: 2
i = 3
j = 4

i: 3
i = 4
j = 4
\end{lstlisting}


\medskip %END OF continue







\medskip %START OF map.set() 
\pagebreak
\subsection{Map.prototype.set()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set}

\begin{itemize}
	\item The set() method adds or updates an entry in a Map object with a specified key and a value.
	\item set(key, value)
	\item The key of the element to add to the Map object. The key may be any JavaScript type (any primitive value or any type of JavaScript object).
	\item The value of the element to add to the Map object. The value may be any JavaScript type (any primitive value or any type of JavaScript object).
	\item The Map object.
\end{itemize}

\begin{lstlisting}[title=Example map.set(), captionpos=t]
const map1 = new Map();
map1.set('bar', 'foo');

console.log(map1.get('bar'));
// expected output: "foo"

console.log(map1.get('baz'));
// expected output: undefined
\end{lstlisting}


\medskip %END OF  map.set() 






\medskip %START OF substring() 
\pagebreak
\subsection{String.prototype.substring()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring}

\begin{itemize}
	\item The substring() method returns the part of the string between the start and end indexes, or to the end of the string.
	\item substring(indexStart)
	\item substring(indexStart, indexEnd)
\end{itemize}

\begin{lstlisting}[title=Example substring(), captionpos=t]
const str = 'Mozilla';

console.log(str.substring(1, 3));
// expected output: "oz"

console.log(str.substring(2));
// expected output: "zilla"
\end{lstlisting}

\begin{lstlisting}[title=Example substring(), captionpos=t]
const anyString = 'Mozilla';

// Displays 'M'
console.log(anyString.substring(0, 1));
console.log(anyString.substring(1, 0));

// Displays 'Mozill'
console.log(anyString.substring(0, 6));

// Displays 'lla'
console.log(anyString.substring(4));
console.log(anyString.substring(4, 7));
console.log(anyString.substring(7, 4));

// Displays 'Mozilla'
console.log(anyString.substring(0, 7));
console.log(anyString.substring(0, 10));
\end{lstlisting}


\medskip %END OF  substring() 







\medskip %START OF lowercase/uppercase() 
\pagebreak
\subsection{String.prototype.toLowerCase() String.prototype.toUpperCase()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase}
\medskip
\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase}


\begin{itemize}
	\item The toLowerCase() method returns the calling string value converted to lower case.
	\item toLowerCase()
	\item The toUpperCase() method returns the calling string value converted to uppercase (the value will be converted to a string if it isn't one).
	\item toUpperCase()
\end{itemize}

\begin{lstlisting}[title=Example toLowerCase(), captionpos=t]
const sentence = 'The quick brown fox jumps over the lazy dog.';

console.log(sentence.toLowerCase());
// expected output: "the quick brown fox jumps over the lazy dog."
\end{lstlisting}

\begin{lstlisting}[title=Example toUpperCase(), captionpos=t]
const sentence = 'The quick brown fox jumps over the lazy dog.';

console.log(sentence.toUpperCase());
// expected output: "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG."
\end{lstlisting}


\medskip %END OF  lowercase/uppercase() 







\medskip %START OF THIS 
\pagebreak
\subsection{this}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this}



\begin{itemize}
	\item In most cases, the value of this is determined by how a function is called (runtime binding). It can't be set by assignment during execution, and it may be different each time the function is called
\end{itemize}

\begin{lstlisting}[title=Example this, captionpos=t]
const test = {
  prop: 42,
  func: function() {
    return this.prop;
  },
};

console.log(test.func());
// expected output: 42
\end{lstlisting}
\medskip %END OF THIS









\medskip %START OF Object.VALUES() 
\pagebreak
\subsection{Object.values()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Object/values}


\begin{itemize}
	\item The Object.values() method returns an array of a given object's own enumerable property values, in the same order as that provided by a for...in loop.
	\item (The only difference is that a for...in loop enumerates properties in the prototype chain as well.)
	\item Object.values(obj)
\end{itemize}

\begin{lstlisting}[title=Example Object.values(), captionpos=t]
const object1 = {
  a: 'somestring',
  b: 42,
  c: false
};

console.log(Object.values(object1));
// expected output: Array ["somestring", 42, false]
\end{lstlisting}


\begin{lstlisting}[title=Example values(), captionpos=t]
const obj = { foo: 'bar', baz: 42 };
console.log(Object.values(obj)); // ['bar', 42]

// Array-like object
const arrayLikeObj1 = { 0: 'a', 1: 'b', 2: 'c' };
console.log(Object.values(arrayLikeObj1 )); // ['a', 'b', 'c']

// Array-like object with random key ordering
// When using numeric keys, the values are returned in the keys' numerical order
const arrayLikeObj2 = { 100: 'a', 2: 'b', 7: 'c' };
console.log(Object.values(arrayLikeObj2 )); // ['b', 'c', 'a']

// getFoo is property which isn't enumerable
const my_obj = Object.create({}, { getFoo: { value() { return this.foo; } } });
my_obj.foo = 'bar';
console.log(Object.values(my_obj)); // ['bar']

// non-object argument will be coerced to an object
console.log(Object.values('foo')); // ['f', 'o', 'o']
\end{lstlisting}
\medskip %END OF Object.VALUES()






\medskip %START OF constructor 
\pagebreak
\subsection{constructor}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor}


\begin{itemize}
	\item The constructor method is a special method of a class for creating and initializing an object instance of that class.
	\item constructor() { /* … */ }
	\item constructor(argument0, argument1, /* … ,*/ argumentN) { /* … */ }

\end{itemize}

\begin{lstlisting}[title=Example Classes Constructor, captionpos=t]
class Polygon {
  constructor() {
    this.name = 'Polygon';
  }
}

const poly1 = new Polygon();

console.log(poly1.name);
// expected output: "Polygon"
\end{lstlisting}
\medskip %END OF constructor





\medskip %START OF CLASSES 
\pagebreak
\subsection{Classes}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes}


\begin{itemize}
	\item Classes are a template for creating objects. They encapsulate data with code to work on that data.
	\item Classes in JS are built on prototypes but also have some syntax and semantics that are not shared with ES5 class-like semantics. 
\end{itemize}

\begin{lstlisting}[title=Example Classes, captionpos=t]
class Rectangle {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
  // Getter
  get area() {
    return this.calcArea();
  }
  // Method
  calcArea() {
    return this.height * this.width;
  }
}

const square = new Rectangle(10, 10);

console.log(square.area); // 100
\end{lstlisting}
\medskip %END OF CLASSES








\medskip %START OF FROM() 
\pagebreak
\subsection{Array.from()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from}


\begin{itemize}
	\item The Array.from() static method creates a new, shallow-copied Array instance from an iterable or array-like object.
\end{itemize}

\begin{lstlisting}[title=Example from(), captionpos=t]
console.log(Array.from('foo'));
// expected output: Array ["f", "o", "o"]

console.log(Array.from([1, 2, 3], x => x + x));
// expected output: Array [2, 4, 6]
\end{lstlisting}

\begin{lstlisting}[title=Examples from(), captionpos=t]
// Arrow function
Array.from(arrayLike, (element) => {stuff})
Array.from(arrayLike, (element, index) => {stuff})

// Mapping function
Array.from(arrayLike, mapFn)
Array.from(arrayLike, mapFn, thisArg)

// Inline mapping function
Array.from(arrayLike, function mapFn(element) {stuff})
Array.from(arrayLike, function mapFn(element, index) {stuff})
Array.from(arrayLike, function mapFn(element) {stuff}, thisArg)
Array.from(arrayLike, function mapFn(element, index) {stuff}, thisArg)
\end{lstlisting}


\medskip %END OF FROM()










\medskip %START OF forEach() 
\pagebreak
\subsection{Array.prototype.forEach()}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach}


\begin{itemize}
	\item The forEach() method executes a provided function once for each array element.

\end{itemize}

\begin{lstlisting}[title=Example forEach(), captionpos=t]
const array1 = ['a', 'b', 'c'];

array1.forEach(element => console.log(element));

// expected output: "a"
// expected output: "b"
// expected output: "c"
\end{lstlisting}

\begin{lstlisting}[title=Examples forEach(), captionpos=t]
const words = ['one', 'two', 'three', 'four'];
words.forEach((word) => {
  console.log(word);
  if (word === 'two') {
    words.shift(); //'one' will delete from array
  }
}); // one // two // four

console.log(words); // ['two', 'three', 'four']
\end{lstlisting}


\medskip %END OF forEach()






\medskip %START OF map() constructor
\pagebreak
\subsection{Map() constructor}

\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/Map}


\begin{itemize}
	\item The Map() constructor creates Map objects.
	\item new Map()
	\item new Map(iterable)
	
\end{itemize}

\begin{lstlisting}[title=Example new Map(), captionpos=t]
let myMap = new Map([
  [1, 'one'],
  [2, 'two'],
  [3, 'three'],
])
\end{lstlisting}

\medskip %END OF map() consturctor















%START OF SECTION - ARRAYS

\pagebreak
\section{Array Algorithm Problems}

\medskip %START 
\subsection{Build Array from Permutation}
https://leetcode.com/problems/build-array-from-permutation/

\begin{enumerate}
	\item initialize result array
	\item loop through nums
	\item push nums at each i to the answer 
	\item return result
\end{enumerate}

\begin{lstlisting}[title=Solution with for loop, captionpos=t]
const buildArray = (nums) => {

    let result = [];

    for (let i = 0; i<nums.length; i++) { 
        result.push(nums[nums[i]]);
    }

    return result; 
};
\end{lstlisting}
	
\begin{lstlisting}[title=Solution with map(), captionpos=t]
const buildArray = (nums) => {

    return nums.map(result => nums[result]);
    
};
\end{lstlisting}
\medskip %END 

\pagebreak
\medskip %START 
\subsection{Count Items Matching a Rule}
https://leetcode.com/problems/count-items-matching-a-rule/

\begin{enumerate}
	\item create rule index object
	\item reduce(ans, items) so that ruleIndex[ruleKey] is equal to ruleValue
	\item if equal increase ans by 1
	\item if not equal answer is 0 
\end{enumerate}

\begin{lstlisting}[title=Solution countMatches, captionpos=t]
const countMatches = (items, ruleKey, ruleValue) => {
    
    let ruleIndex = {
        'type': 0,
        'color': 1,
        'name': 2
    };
    
    return items.reduce((ans,item) => 
    item[ruleIndex[ruleKey]] === ruleValue ? ans + 1 : ans, 0);
};
\end{lstlisting}
\medskip %END 

\pagebreak
\medskip %START
\subsection{Create Target Array in the Given Order}
https://leetcode.com/problems/create-target-array-in-the-given-order/

\begin{enumerate}
	\item initialize empty target array
	\item loop through array 
	\item loop though each index of the previous loop
	\item if array[i] is less than or equal to inner loop, increment inner loop
	\item loop in the nums array giving target the value: target[array[j]] = nums[i]
	\item return target 
\end{enumerate}

\begin{lstlisting}[title=Solution createTargetArray, captionpos=t]
const createTargetArray = (nums, array) => {

    let result = [];
    
    for ( let i=0; i<array.length; i++) {
        for (let j=0; j<i; j++) {
            if (array[i] <= array[j]) {
                array[j]++;
            }
        }
    }
    
    for (let i in nums) {
        result[array[i]] = nums[i];
    }
    
    return result;
};
\end{lstlisting}

\begin{lstlisting}[title=Solution createTargetArray with splice(), captionpos=t]
const createTargetArray = (nums, index) => {
    
    let target = []
    
    for(let i in nums){
        target.splice(index[i], 0, nums[i])
    }
        
    return target
};
\end{lstlisting}
\medskip %END

\pagebreak
\medskip %START 
\subsection{Decode XORed Array}
https://leetcode.com/problems/decode-xored-array/

\begin{enumerate}
	\item initialize result with first in array
	\item for loop through encoded
	\item push result through result[i] \^\ encoded[i]
	\item return result
\end{enumerate}

\begin{lstlisting}[title=Solution decode, captionpos=t]
const decode = (encoded, first) => {

    let result = [first];
    
    for (let i = 0; i<encoded.length; i++) {
        result.push(result[i] ^ encoded[i]);
    }
    
    return result;
};
\end{lstlisting}
\medskip %END


\pagebreak
\medskip %START 
\subsection{Decompress Run-Length Encoded List}
https://leetcode.com/problems/decompress-run-length-encoded-list/

\begin{enumerate}
	\item initialize empty result array
	\item loop through nums, starting from 1, increasing by 2 each time
	\item push result into a new array nums[i-1]
	\item fill new array with nums[i]
	\item return result 
\end{enumerate}

\begin{lstlisting}[title=Solution decompressRLEList, captionpos=t]
const decompressRLEList = (nums) => {

    let result = [];
    
    for (let i=1; i< nums.length; i+=2) {
        result.push(...new Array(nums[i-1]).fill(nums[i]));
    }
    
    return result;
};
\end{lstlisting}
\medskip %END 



\pagebreak
\medskip %START  
\subsection{Final Value of Variable After Performing Operations}
https://leetcode.com/problems/final-value-of-variable-after-performing-operations/

\begin{enumerate}
	\item initialize count at 0
	\item loop through the values of operations (not the index)
	\item if i is equal to 'X++' or '++X' increment
	\item else decrement 
	\item return final count
\end{enumerate}

\begin{lstlisting}[title=Solution finalValueAfterOperations, captionpos=t]
const finalValueAfterOperations = (operations) => {

    let result = 0;

    for (let i of operations) {
        if (i === 'X++' || i === '++X') {
            result++;
        } else result --;
    }
    
    return result;
};
\end{lstlisting}
\medskip %END 

\pagebreak
\medskip %START  
\subsection{Concatenation of Array}
https://leetcode.com/problems/concatenation-of-array/

\begin{enumerate}
	\item take nums and split it using ... operator
	\item return nums twice in a single [ ]
\end{enumerate}

\begin{lstlisting}[title=Solution getConcatenation, captionpos=t]
const getConcatenation = (nums) => {

    return [...nums, ...nums];
    
}
\end{lstlisting}
\medskip %END 

\pagebreak
\medskip %START  
\subsection{Kids With the Greatest Number of Candies}
https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/

\begin{enumerate}
	\item initialize results array
	\item initialize max value tracker
	\item loop through candies array 
	\item create logic for max value
	\item loop through candies[i]
	\item test each candies with extraCandies to see if value is true 
	\item return result 
\end{enumerate}

\begin{lstlisting}[title=Solution kidsWithCandies with for-of loop, captionpos=t]
const kidsWithCandies = (candies, extraCandies) => {

    let result = [];
    let max = 0;

    for (const val of candies) {
        val > max && (max = val);
    }
    for (let i = 0; i< candies.length; ++i) {
        result.push(candies[i] + extraCandies >= max);
    }

    return result; 
};
\end{lstlisting}

\begin{lstlisting}[title=Solution kidsWithCandies with for loop, captionpos=t]
var kidsWithCandies = function(candies, extraCandies) {
    
    let answer = []
    let max = 0
    
    for(let i=0; i<candies.length; i++){
        candies[i] > max && (max = candies[i])
    }
    
    for(let j=0; j<candies.length; j++){
        answer.push(candies[j] + extraCandies >= max)
    }
    return answer
};
\end{lstlisting}
\medskip %END 

\pagebreak
\medskip %START  
\subsection{Maximum Number of Words Found in Sentences}
https://leetcode.com/problems/maximum-number-of-words-found-in-sentences/

\begin{enumerate}
	\item Initialize max and temp variables at zero 
	\item Loop through sentence.length 
	\item Split sentences based on parentheses and add the length of each to temp variable 
	\item Find which value of temp or max is biggest and pass to max
	\item Return max
\end{enumerate}

\begin{lstlisting}[title=Solution mostWordsFound, captionpos=t]
const mostWordsFound = (sentence) => {

    let result = 0;
    let temp = 0;

    for (let i=0; i < sentence.length; i++) {
        temp = sentence[i].split(" ").length;
        if(temp>result){
            result = temp;
        }
    }
    
    return result;
};
\end{lstlisting}

\begin{lstlisting}[title=Solution mostWordsFound with for-in loop and Math.max, captionpos=t]
const mostWordsFound = (sentence) => {
    
    let max = 0;
    let temp = 0;
    
    for (let i in sentence) {
        temp = sentence[i].split(" ").length;
    }
    
    return Math.max(max, temp)
}
\end{lstlisting}
\medskip %END 



\pagebreak
\medskip %START  
\subsection{Number of Good Pairs}
https://leetcode.com/problems/number-of-good-pairs/

\begin{enumerate}
	\item initialize counter
	\item loop through nums array
	\item loop again starting at i+1 
	\item logic if(nums[i] === nums[j] increase count
	\item return count
\end{enumerate}

\begin{lstlisting}[title=Solution numIdenticalPairs, captionpos=t]
const numIdenticalPairs =  (nums) => {

    let result = 0;

    for (let i=0; i<nums.length; i++) {
        for (let j=i+1; j<nums.length; j++) {
            if (nums[i] === nums[j]) {
                result++;
            }
        }
    }
    
    return result; 
};
\end{lstlisting}

\medskip %END 

\pagebreak
\medskip %START  
\subsection{Shuffle String}
https://leetcode.com/problems/shuffle-string/

\begin{enumerate}
	\item initialize empty results array
	\item loop through idices array
	\item tie the indices to the s parameter
	\item return the result and join() it together since we are looking for a string 
\end{enumerate}

\begin{lstlisting}[title=Solution restoreString, captionpos=t]
const restoreString = (s, indices) => {
    
    let result = [];

    for(let i = 0; i<indices.length; i++){
        result[indices[i]] = s[i];
    }

    return result.join('');
};
\end{lstlisting}

\medskip %END 

\pagebreak
\medskip %START  
\subsection{Richest Customer Wealth}
https://leetcode.com/problems/richest-customer-wealth/

\begin{enumerate}
	\item initialize an answer
	\item loop through the people, accounts
	\item initialize temp variable
	\item loop through the banks accounts[i]
	\item add all their wealth to temp 
	\item use math.max to find the highest number 
	\item return the account with most wealth
\end{enumerate}

\begin{lstlisting}[title=Solution maximumWealth, captionpos=t]
const maximumWealth = (accounts) => {

    let result = 0;

    for(let i=0; i<accounts.length; i++){
        let temp = 0;
        for(let j = 0; j< accounts[i].length; j++){
            temp += accounts[i][j];
        }
        result = Math.max(result, temp);
    }
    
    return result;
};
\end{lstlisting}

\medskip %END 

\pagebreak
\medskip %START  
\subsection{Running Sum of 1d Array}
https://leetcode.com/problems/running-sum-of-1d-array/

\begin{enumerate}
	\item create loop from 1(i) to end of array 
	\item add nums[i] and nums[i-1] to array
	\item return nums array
\end{enumerate}

\begin{lstlisting}[title=Solution runningSum, captionpos=t]
const runningSum = (nums) => {
    
    for (let i = 1; i < nums.length; i++) {
        nums[i] += nums [i-1];
    }

    return nums;
};
\end{lstlisting}

\medskip %END 


\pagebreak
\medskip %START  
\subsection{Shuffle the Array}
https://leetcode.com/problems/shuffle-the-array/

\begin{enumerate}
	\item create empty result array
	\item loop through n with i< n 
	\item push into nums[i] 
	\item push into nums[i+n]
	\item return result
\end{enumerate}

\begin{lstlisting}[title=Solution shuffle, captionpos=t]
const shuffle =  (nums, n) => {
    
    let result = [];

    for (let i = 0; i < n; i++) {
        result.push(nums[i]);
        result.push(nums[i+n]);
    }

    return result;
};
\end{lstlisting}

\medskip %END 

\pagebreak
\medskip %START  
\subsection{How Many Numbers Are Smaller Than the Current Number}
leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/

\begin{enumerate}
	\item Initialize empty results array
	\item Initialize sorted array
	\item Slice() sorted array to duplicated
	\item Sort() sorted array using ((a, b) $\rightarrow$ a - b) so it works for numbers 
	\item For loop through nums
	\item Compare the value of sorted array with nums array and push into results the indexOf at which sorted is in nums[i]
	\item Return results 
\end{enumerate}

\begin{lstlisting}[title=Solution smallerNumbersThanCurrent, captionpos=t]
const smallerNumbersThanCurrent = (nums) => {

    let result = [];
    let sorted = nums.slice().sort((a,b)=>a-b);

    for (let i = 0; i<nums.length; i++) {
        result.push(sorted.indexOf(nums[i]));
    }

    return result;
};
\end{lstlisting}

\medskip %END 

\pagebreak
\medskip %START  
\subsection{Sum of All Odd Length Subarrays}
https://leetcode.com/problems/sum-of-all-odd-length-subarrays/

\begin{enumerate}
	\item Initialize result at 0 
	\item For loop through arr starting at 1
	\item Start from second element and add to itself the first element and so on. So each index has the value of all previous indexes added to it
	\item loop through all start indices 
	\item End is initially start and look for all odd (+=2) subarrays
	\item Sum up += the query in result 
	\item Return result 
	\item Setup helper sumBetween function that takes sum from start to end 
\end{enumerate}

\begin{lstlisting}[title=Solution sumOddLengthSubarrays with helper function, captionpos=t]
const sumOddLengthSubarrays = (arr) => {

    let result = 0;
 
    for(let i = 1; i<arr.length; i++){
        arr[i] += arr[i - 1];
    }

    for(let start = 0; start<arr.length; start++){
        for(let end = start; end<arr.length; end +=2){
            result += sumBetween(start, end);
        }
    }
    
    return result;

    function sumBetween(start, end){
        return arr[end] - (arr[start -1] || 0);
    };
};
\end{lstlisting}

\begin{lstlisting}[title=Solution sumOddLengthSubarrays with parseInt, captionpos=t]
const sumOddLengthSubarrays = (arr) => {

    let result = 0;
    let n = arr.length;

    for(let i = 0; i< n; ++i) {
        result += parseInt(((i + 1) * (n - i) + 1) / 2) * arr[i];
    }
    
    return result;
};
\end{lstlisting}


\begin{lstlisting}[title=Solution sumOddLengthSubarrays with for loops and modulo, captionpos=t]
const sumOddLengthSubarrays = (arr) => {

    let result = 0;

    for(let i=0; i<arr.length; i++){
        for(let j=i; j<arr.length; j++){
            if((i-j)%2==0){
                for(let k=i;k<=j;k++){
                    result+=arr[k];
                }
            }
        }
    }

    return result;
}
\end{lstlisting}

\begin{lstlisting}[title=Solution sumOddLengthSubarrays with while loop, captionpos=t]
var sumOddLengthSubarrays = function(arr) {

    let i=1;
    let sum=0;

     while(i<=arr.length){
         for(let j=0;j<=arr.length-i;j++){
              for(let k=j;k<i+j;k++){
                 sum+=arr[k]
              }
         }
         i+=2
     }
     
     return sum
 };
\end{lstlisting}


\medskip %END 


\pagebreak %START  
\medskip 
\subsection{Count Number of Pairs With Absolute Difference K}
https://leetcode.com/problems/count-number-of-pairs-with-absolute-difference-k/

\begin{enumerate}
	\item Create empty object
	\item Initialize answer at zero
	\item Loop through nums giving values to the object
	\item Loop through nums if obj[nums[i]-k] += that value to answer
	\item Return Answer
\end{enumerate}



\begin{lstlisting}[title=Solution countKDifference, captionpos=t]
const countKDifference = (nums, k) => {
    
    let obj = {};
    let result = 0;

    for (let i of nums) {
        obj[i] ? obj[i]++ : obj[i] = 1;
    }
    
    for (let i=0; i<nums.length; i++) {
        if(obj[nums[i] -k]){
            result += obj[nums[i] - k];
        }
    }
    
    return result; 
};
\end{lstlisting}
\medskip %END









\pagebreak %START  
\medskip 
\subsection{Minimum Number of Moves to Seat Everyone}
https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/

\begin{enumerate}
	\item Initialize answer variable
	\item Sort seats
	\item Sort students
	\item Loop through arrays finding the absolute value of the number and += to answer
	\item Return answer
\end{enumerate}



\begin{lstlisting}[title=Solution minMovesToSeat, captionpos=t]
const minMovesToSeat = (seats, students) => {
    
    let result = 0;
    
    seats = seats.sort((a,b) => a-b);
    students = students.sort((a,b) => a-b);
    
    for (let i in seats) {
        result += Math.abs(seats[i] - students[i]);
    }
    
    return result;
};
\end{lstlisting}
\medskip %END






\pagebreak %START  
\medskip 
\subsection{Minimum Amount of Time to Fill Cups}
https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/

\begin{enumerate}
	\item Initalize answer to zero
	\item Sort the amount array 
	\item Whie loop amount 1 and 2 decrement them until zero while increasing answer
	\item Sort in the while loop to keep the biggest amounts furthest away 
	\item Add the remaining amount to the answer in second (only 1 amount so will always be 1 per second)
	\item Return answer
\end{enumerate}



\begin{lstlisting}[title=Solution fillCups, captionpos=t]
const fillCups = (amount) => {
    
    let result = 0;

    amount.sort((a, b) => a - b);
    
    while (amount[1] && amount[2]) {
        answer++;
        amount[1]--;
        amount[2]--;
        amount.sort((a, b) => a - b);
    }
    
    result += amount[2];
    return result;
};
\end{lstlisting}
\medskip %END









\pagebreak %START  
\medskip 
\subsection{Assign Cookies}
https://leetcode.com/problems/assign-cookies/

\begin{enumerate}
	\item Initalize empty answer
	\item Sort (g) children and (s) cookies 
	\item Whie loop amount 1 and 2 decrement them until zero while increasing answer
	\item Loop with forEach through (s) and if  child is greater than g[answer]  increment answer (this needs work not sure exactly what is happening here)
	\item Return answer
\end{enumerate}



\begin{lstlisting}[title=Solution findContentChildren, captionpos=t]
const findContentChildren = (g,s) => {
    
    let result = 0;
    
    g.sort((a,b) => a-b);
    s.sort((a,b) => a-b);
    
    s.forEach((child) => {
        if(child >= g[result]){
            result++;
        }
    })
    
    return result;
}
\end{lstlisting}
\medskip %END









%END OF SECTION - ARRAYS







%START OF SECTION - STRINGS


\pagebreak
\section{String Algorithm Problems}



\medskip %START  
\subsection{Defanging an IP Address}
https://leetcode.com/problems/defanging-an-ip-address/

\begin{enumerate}
	\item split and join the address
	\item return return address
\end{enumerate}

\begin{lstlisting}[title=Solution defangIPaddr, captionpos=t]
const defangIPaddr = (address) => {

    return address.split('.').join('[.]');
    
};
\end{lstlisting}
\medskip %END 



\pagebreak %START  
\medskip 
\subsection{Jewels and Stones}
https://leetcode.com/problems/jewels-and-stones/

\begin{enumerate}
	\item Initialize count to zero
	\item Loop through jewels string
	\item Loop through stones string
	\item Logic to check if each part of stones is equal to jewels
	\item If equal add to count
	\item Return count
\end{enumerate}

\begin{lstlisting}[title=Solution numJewelsInStones, captionpos=t]
const numJewelsInStones = (jewels, stones) => {
    
    let result = 0;
    
    for(let i = 0; i<jewels.length; i++){
        for(let j=0; j<stones.length; j++){
            if(stones[j] === jewels[i]){
                result ++;
            }
        }
    }

    return result;
};
\end{lstlisting}
\medskip %END 



\pagebreak %START  
\medskip 
\subsection{Goal Parser Interpretation}
https://leetcode.com/problems/goal-parser-interpretation/

\begin{enumerate}
	\item Split command by () join o in place
	\item Split command by (al) join al in place
	\item Return command
\end{enumerate}

\begin{lstlisting}[title=Solution interpret, captionpos=t]
const interpret = (command) => {

    return command.split('()').join('o').split('(al)').join('al');
    
};
\end{lstlisting}
\medskip %END 




\pagebreak %START  
\medskip 
\subsection{Cells in a Range on an Excel Sheet}
https://leetcode.com/problems/cells-in-a-range-on-an-excel-sheet/

\begin{enumerate}
	\item Initialize empty answer array
	\item Initialize array with string s [col1, row1, EMPTY SPACE, col2, row2] = s
	\item Loop through columns - c with charCodeAt
	\item Loop through rows - r with +row
	\item Push answer to a string using fromCharCode(c) + r
	\item Return answer
\end{enumerate}

\begin{lstlisting}[title=Solution cellsInRange, captionpos=t]
const cellsInRange = (s) => {

    let result = [];
    let [col1, row1, , col2, row2] = s;
    
    for(let c = col1.charCodeAt(0), ce = col2.charCodeAt(0); c<= ce; c++){
        for(let r = +row1, re = +row2; r<=re; r++){
            result.push(String.fromCharCode(c) + r);
        }
    }
    
    return result;
};
\end{lstlisting}
\medskip %END 




\pagebreak %START  
\medskip 
\subsection{Split a String in Balanced Strings}
https://leetcode.com/problems/split-a-string-in-balanced-strings/

\begin{enumerate}
	\item Initialize empty matches variable
	\item Initalize empty balance variable
	\item Loop through s.length
	\item If each S[i] is equal to L add +1 to balance, else reduce it by one
	\item If balance is equal to zero add +1 to matches 
	\item Return matches 
\end{enumerate}

\begin{lstlisting}[title=Solution balancedStringSplit with balance counter, captionpos=t]
const balancedStringSplit = (s) => {
    
    let result = 0;
    let balance = 0;

    for (let i = 0; i < s.length; i++) {
        s[i] === 'L' ? balance++ : balance--;
        if (balance === 0) {
            result++;
        }
    }

    return result;
};
\end{lstlisting}

\begin{lstlisting}[title=Solution balancedStringSplit with stack, captionpos=t]
const balancedStringSplitStack = (s) => {

    let result = 0;
    let stack = [];

    stack.push(s[0])

    for (let i = 1; i < s.length; i++) {
        let top = stack[stack.length - 1];
        if (top !== undefined && top !== s[i]) {
          stack.pop();
        } else {
            stack.push(s[i]);
        }
        if (stack.length === 0) {
            result += 1;
        }
    }

    return result;
};
\end{lstlisting}
\medskip %END 



\pagebreak %START  
\medskip 
\subsection{Sorting the Sentence}
https://leetcode.com/problems/sorting-the-sentence/

\begin{enumerate}
	\item Return s.split to put into parts
	\item Sort by number orders and use x[x.length-1] to find last item (the number)
	\item Map to remove the last item (the number) from the words
	\item Join(' ') to turn it back into a string as opposed to array
\end{enumerate}

\begin{lstlisting}[title=Solution sortSentence, captionpos=t]
const sortSentence = (s) => {

    return s.split(' ')
        .sort((a,b) => a[a.length-1] - b[b.length-1])
        .map((word) => word.slice(0, word.length-1))
        .join(' ');
        
 };
\end{lstlisting}
\medskip %END 


\pagebreak %START  
\medskip 
\subsection{Decode the Message}
https://leetcode.com/problems/decode-the-message/

\begin{enumerate}
	\item Create map variable of empty map()
	\item Set start at 97
	\item Initialize empty result string
	\item For of loop through key if map has i or is empty continue 
	\item If not set i as a string fromCharCode(start++)
	\item map.set(' ', ' ')
	\item For of loop through message and add map.get(m) to result
	\item Return result
\end{enumerate}

\begin{lstlisting}[title=Solution decodeMessage, captionpos=t]
const decodeMessage = (key, message) => {
    
    let map = new Map();
    let start=97;
    let result="";

    for(let i=0; i<key.length;i++){
        if(map.has(key[i])||key[i]===" "){
            continue;
        } else {
        map.set(key[i],String.fromCharCode(start++)) 
        }
    }
    
    map.set(" "," "); 
    
    for(let m of message){
        result+=map.get(m);
    }
    
    return result;
};
\end{lstlisting}
\medskip %END 




\pagebreak %START  
\medskip 
\subsection{Maximum Nesting Depth of the Parentheses}
https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/

\begin{enumerate}
	\item Initialize answer int at zero
	\item Initialize counter int at zero
	\item For loop through s
	\item If s[i] is equal to ( answer.math.max(answer, ++counter)
	\item Else decrement counter
	\item Return answer
\end{enumerate}

\begin{lstlisting}[title=Solution maxDepth, captionpos=t]
const maxDepth = (s) => {

    let result = 0;
    let count = 0;
    
    for (let i = 0; i < s.length;  i++) {
        if (s[i] === '(') {
            result = Math.max(result, ++count);
        } else if (s[i] === ')') {
            count--;
        }  
    }
    
    return result
};
\end{lstlisting}

\begin{lstlisting}[title=Solution maxDepth with split() and reduce(), captionpos=t]
const maxDepth = (s) => {

    let l = 0;
    let r = 0;
    
    return s.split('').reduce((depth, c) => {
        if (c === '(') l++;
        if (c === ')') r++;
        
        return Math.max(l - r, depth);
    }, 0)
}
\end{lstlisting}
\medskip %END 





\pagebreak %START  
\medskip 
\subsection{Fizz Buzz}
https://leetcode.com/problems/fizz-buzz/

\begin{enumerate}
	\item Initialize empty answer array
	\item Loop through n starting at 1 and ending when <= n
	\item If i  modulo 15 is equal to zero push string 'FizzBuzz'
	\item Else if i  modulo 5 is equal to zero push string 'Buzz'
	\item Else if i  modulo 3 is equal to zero push string 'Fizz'
	\item Else push string i 
	\item Return snswer 
\end{enumerate}

\begin{lstlisting}[title=Solution fizzBuzz with for loop, captionpos=t]
const fizzBuzz = (n) => {

    const result = [];
    
    for (let i=1; i<=n; i++) {
        if (i % 15 === 0 ) {
            result.push('FizzBuzz');
        } else if (i % 3 === 0) {
            result.push('Fizz');
        } else if (i % 5 === 0) {
            result.push('Buzz');
        } else {
            result.push(i.toString());
        }
    }
    
    return result;
};
\end{lstlisting}

\begin{lstlisting}[title=Solution fizzBuzz ES6, captionpos=t]
var fizzBuzz = function(n) {
    return new Array(n).fill(0).map((a, i) => (++i % 3 ? '' : 'Fizz') + (i % 5 ? '' : 'Buzz') || '' + i)
};
\end{lstlisting}
\medskip %END 







\pagebreak %START  
\medskip 
\subsection{Check If Two String Arrays are Equivalent}
https://leetcode.com/problems/check-if-two-string-arrays-are-equivalent/

\begin{enumerate}
	\item Join('') word1 and word2 so they become strings
	\item Compare the two strings so they are equal
	\item Return true if equal
	\item Return false if not equal
\end{enumerate}

\begin{lstlisting}[title=Solution arrayStringsAreEqual, captionpos=t]
const arrayStringsAreEqual = (word1, word2) => {
    
    let w1 = word1.join('');
    let w2 = word2.join('');
    
    if (w1 === w2) {
        return true;
    } else {
        return false;
    }
};
\end{lstlisting}

\begin{lstlisting}[title=Solution arrayStringsAreEqual ES6, captionpos=t]
var arrayStringsAreEqual = function(word1, word2) {
    return word1.join('') === word2.join('')
};
\end{lstlisting}
\medskip %END 





\pagebreak %START  
\medskip 
\subsection{Count the Number of Consistent Strings}
https://leetcode.com/problems/count-the-number-of-consistent-strings/

\begin{enumerate}
	\item Initialize empty answer array 
	\item For of loop through i of words
	\item Set word equals to i 
	\item Loop through word.length and set wordChar as word[j]
	\item If !allowed includes wordChar break
	\item Else if j===word.length -1 push word.length to answer
	\item Return answer.length
\end{enumerate}

\begin{lstlisting}[title=Solution countConsistentStrings with loops, captionpos=t]
const countConsistentStrings = (allowed, words) => {
    
    let result = [];
    
    for(let i of words){
        let word = i;
        for(let j = 0; j<word.length; j++){
            let wordChar = word[j];
            if(!allowed.includes(wordChar)){
              break;
            } else if(j === word.length-1){
                result.push(word.length);
            }
        }
    }
    
    return result.length;
};
\end{lstlisting}

\begin{lstlisting}[title=Solution countConsistentStrings ES6, captionpos=t]
const countConsistentStrings = (allowed, words) => {

    let set = new Set(allowed)
    
    return words.reduce((a, w) => {
      return w.split('').every(l => set.has(l)) ? ++a : a
    }, 0)
    
  }
\end{lstlisting}
\medskip %END 





\pagebreak %START  
\medskip 
\subsection{To Lower Case}
https://leetcode.com/problems/to-lower-case/

\begin{enumerate}
	\item Return s.toLowerCase()
\end{enumerate}

\begin{lstlisting}[title=Solution toLowerCase, captionpos=t]
const toLowerCase = (s) => {

    return s.toLowerCase()
    
};
\end{lstlisting}

\begin{lstlisting}[title=Solution toLowerCase with hex code, captionpos=t]
//hex code for letter 'A' is 0x41 and for letter 'a' is 0x61. That's a diff of 0x20.
const toLowerCase = (str) => {

    let i = 0;
    let result = "";
    
    while (i < str.length) {
        result += String.fromCharCode(str.charCodeAt(i) | 0x20);
        i++;
    }
    
    return result;
};
\end{lstlisting}
\medskip %END 


\pagebreak %START  
\medskip 
\subsection{Rings and Rods}
https://leetcode.com/problems/rings-and-rods/

\begin{enumerate}
	\item Initialize new Map() called map
	\item Initialize answer int to zero 
	\item Loop through rings.length 
	\item Set color to rings[i]
	\item Set rod to +rings[i+1]
	\item If !map has rod Map.set rod, new Set()
	\item Map.get rod.add(color)
	\item Loop through map with [rod, setColors]
	\item If set color size is equal to 3 answer ++
	\item Return answer
\end{enumerate}

\begin{lstlisting}[title=Solution countPoints, captionpos=t]
const countPoints = (rings) => {
    
    let map = new Map;
    let result = 0;
    
    for(let i = 0; i<rings.length; i += 2){
        let color = rings[i];
        let rod = +rings[i + 1];
        if(!map.has(rod))
            map.set(rod, new Set());
            map.get(rod).add(color);
    }
    
    for(let [rod, setColors] of map){
        if(setColors.size === 3){
            result++;
        }
    }
    
    return result;
};
\end{lstlisting}

\begin{lstlisting}[title=Solution countPoints is this slower?, captionpos=t]
var countPoints = function(rings) {

    let rods = Array(10).fill("");

    for(let i = 0; i < rings.length; i += 2){
        if(!(rods[rings[i+1]].includes(rings[i]))) rods[rings[i+1]] += rings[i]
    }
    
    return rods.filter(rod => rod.length > 2).length
};
\end{lstlisting}
\medskip %END 



\pagebreak %START  
\medskip 
\subsection{Truncate Sentence}
https://leetcode.com/problems/truncate-sentence/

\begin{enumerate}
	\item Split string so that it becomes array
	\item Slice the array from index 0 to index k (desired length)
	\item Join the array into a string (' ') removing commas
	\item Return the string
\end{enumerate}

\begin{lstlisting}[title=Solution truncateSentence, captionpos=t]
const truncateSentence = (s, k) => {

    return s.split(' ').slice(0,k).join(' ');
    
 };
\end{lstlisting}
\medskip %END 




\pagebreak %START  
\medskip 
\subsection{Check if the Sentence Is Pangram}
https://leetcode.com/problems/check-if-the-sentence-is-pangram/

\begin{enumerate}
	\item Make new Set (what does this mean?)
	\item Split('') the sentence
	\item Set size to equal 26
	\item Return
\end{enumerate}

\begin{lstlisting}[title=Solution checkIfPangram, captionpos=t]
const checkIfPangram = (sentence) => {
    
    return new Set(sentence.split("")).size === 26;
    
};
\end{lstlisting}
\medskip %END 


\pagebreak %START  
\medskip 
\subsection{Count Asterisks}
https://leetcode.com/problems/count-asterisks/

\begin{enumerate}
	\item Set count and result counters
	\item For loop through s.length
	\item If s[i] === | increment count
	\item If count is multiple of two and s[i] = * then increment result
	\item Return result
\end{enumerate}

\begin{lstlisting}[title=Solution countAsterisks, captionpos=t]
const countAsterisks = (s) => {
    
    let count = 0;
    let result = 0;
    
    for (let i = 0; i < s.length; i++) {
        if (s[i] === '|') {
           count ++
        }
        if (count % 2 === 0 && s[i] === '*') {
            result ++
        }
    }
    
    return result;
};
\end{lstlisting}

\begin{lstlisting}[title=My messy solution while learning, captionpos=t]
var countAsterisks = function(s) {
    
    let count = 0
    let  s2 = s.split('|')
    let temp = []
     
     for(let i=0; i<s2.length; i+=2){
         temp = s2[i].split('').join('')
         for(let j=0; j<temp.length;j++){
             if(temp[j] === '*'){
                 count++
             }
         }
     }
     
     return count
 };
\end{lstlisting}
\medskip %END



\pagebreak %START  
\medskip 
\subsection{Unique Morse Code Words}
https://leetcode.com/problems/unique-morse-code-words/

\begin{enumerate}
	\item Set const morse to morse code from questions
	\item Initialize answer to new Set
	\item For of loop through words with word
	\item Initialize transform as empty string
	\item For loop through word to seperate each character
	\item Set i euqal to char.charCodeAt(0) - 97
	\item Add morse[i] to transform 
	\item Add transform to answer Set
	\item Return size of answer set
\end{enumerate}

\begin{lstlisting}[title=Solution uniqueMorseRepresentations, captionpos=t]
let morse = [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."];

const uniqueMorseRepresentations = (words) => {
    
    let result = new Set;
    
    for (let word of words) {
        let transform = '';
        for (let char of word) {
            let i = char.charCodeAt(0) - 97;
            transform += morse[i];
        }
        result.add(transform);
    }
    
    return result.size;
};
\end{lstlisting}


\begin{lstlisting}[title=Solution uniqueMorseRepresentations with object, captionpos=t]
const alphabet = {
    a: '.-', b: '-...',   c: '-.-.', d: '-..', e: '.', f: '..-.', g: '--.', h: '....', i: '..',  j: '.---',  k: '-.-',  l: '.-..', m: '--',
    n: '-.',  o: '---', p: '.--.',  q: '--.-',  r: '.-.', s: '...', t: '-', u: '..-', v: '...-', w: '.--', x: '-..-',  y: '-.--', z: '--..' 
}

const uniqueMorseRepresentations = words => {  

    return new Set(words.map(word => word.split('').map(letter => alphabet[letter]).join(''))).size
}
\end{lstlisting}


\medskip %END





\pagebreak %START  
\medskip 
\subsection{Number of Strings That Appear as Substrings in Word}
leetcode.com/problems/number-of-strings-that-appear-as-substrings-in-word/

\begin{enumerate}
	\item Initialize answer to zero 
	\item Loop through patterns
	\item If word includes(patter[i]) increment answer
	\item Return answer
\end{enumerate}



\begin{lstlisting}[title=Solution numOfStrings, captionpos=t]
const numOfStrings = (patterns, word) => {

    let result = 0;
    
    for (let i = 0; i<patterns.length ; i++) {
        if (word.includes(patterns[i])) {
            result++;
        }
    }
    
return result;
};
\end{lstlisting}
\medskip %END




\pagebreak %START  
\medskip 
\subsection{Remove Outermost Parentheses}
https://leetcode.com/problems/remove-outermost-parentheses/

\begin{enumerate}
	\item Initialize empty answer string
	\item Initialize counter to zero 
	\item Loop through s 
	\item If s[i] is equal to ( if counter is greater than zero add ( to answer string and increment counter
	\item Else if s[i] is equal to ) and counter greater than one add ) to answer string and decrement counter
	\item Return answer 
\end{enumerate}



\begin{lstlisting}[title=Solution removeOuterParentheses, captionpos=t]
const removeOuterParentheses = (s) => {
    
    let result = '';
    let counter = 0;
    
    for (let i = 0; i<s.length; i++) {
        if (s[i] === '(') {
            if (counter > 0) {
                result += '(';
            }
            counter++;
        } else if(s[i] === ')') {
            if (counter > 1) {
                result += ')';
            }
            counter--;
        }
    }
    
    return result;
};
\end{lstlisting}
\medskip %END





\pagebreak %START  
\medskip 
\subsection{Replace All Digits with Characters}
https://leetcode.com/problems/replace-all-digits-with-characters/

\begin{enumerate}
	\item loop through s starting at 1 += 2
	\item Initialize value to String fromCharCode(s[i-1].charCodeAt()+Number(s[i]))
	\item Update s to equal s.replace(s[i], value)
	\item Return s
\end{enumerate}



\begin{lstlisting}[title=Solution replaceDigits, captionpos=t]
const replaceDigits = (s) => {
    
    for (let i = 1; i<s.length; i+=2) {
        let value = String.fromCharCode(s[i-1].charCodeAt()+Number(s[i]));
        s = s.replace(s[i], value);
    }
    
    return s;
};
\end{lstlisting}
\medskip %END

%END OF SECTION - STRINGS








%START OF SECTION - HASH TABLES


\pagebreak
\section{Hash Tables}



%START  
\medskip 
\subsection{Destination City}
https://leetcode.com/problems/destination-city/

\begin{enumerate}
	\item Create new set named departure
	\item Loop through paths and add path[0] to departure
	\item Loop through paths again and check if subarray has second index value (if it does not it is unique)
	\item If no second index value, return that value (should be destination)
\end{enumerate}

\begin{lstlisting}[title=Solution destCity, captionpos=t]
const destCity = (paths) => {
    
    let set = new Set();
    
    for (let path of paths) {
        set.add(path[0]);
    }
    for (let path of paths) {
        if (!set.has(path[1])) {
            return path[1];
        }
    }
};
\end{lstlisting}
\medskip %END 





\pagebreak %START  
\medskip   
\subsection{Maximum Number of Pairs in Array}
https://leetcode.com/problems/maximum-number-of-pairs-in-array/

\begin{enumerate}
	\item Initialize new map and count
	\item Loop through nums
	\item If map[nums[i]] then go ahead and delete map[nums[i]] and increment count
	\item Else replace map[nums[i]] with one
	\item Return [count, Object.values(map).length]
\end{enumerate}

\begin{lstlisting}[title=Solution numberOfPairs, captionpos=t]
const numberOfPairs = (nums) => {
    
    let map = new Map();
    let result = 0;
    
    
    for (let i=0;i<nums.length;i++) {
        if (map[nums[i]]) {
            delete(map[nums[i]]);
            result++;
        } else {
            map[nums[i]] = 1;
        }
    }

    return [result, Object.values(map).length];
};
\end{lstlisting}
\medskip %END



\pagebreak %START  
\medskip   
\subsection{Design an Ordered Stream}
https://leetcode.com/problems/design-an-ordered-stream/

\begin{enumerate}
	\item Created class OrderedStream
	\item Setup constructor
	\item Set pointed to zero and initialize empty list 
	\item Insert (id, value)
	\item Initialize empty chunk array
	\item Set this.list[id-1] to value
	\item While loop through (this.list[this.pointer])
	\item Push (this.list[this.pointer]) into chunk
	\item Increment this.pointer
	\item Return chunk 
\end{enumerate}

\begin{lstlisting}[title=Solution orderedStream, captionpos=t]
class OrderedStream {
    constructor(n) {
      this.pointer = 0;
      this.list = [];
    }
  
    insert(id, value) {
      let chunk = [];
      this.list[id - 1] = value;
      while(this.list[this.pointer]) {
        chunk.push(this.list[this.pointer]);
        this.pointer++;
      }
      
      return chunk;
    }
  }
\end{lstlisting}
\medskip %END




\pagebreak %START  
\medskip   
\subsection{Increasing Decreasing String}
https://leetcode.com/problems/increasing-decreasing-string/

\begin{enumerate}
	\item Initialize arr with Array.from(s) (splitting s into an array of its parts)
	\item Initialize empty answer string
	\item Sort arr 
	\item While loop through arr.length
	\item Filter arr so that if i === 0 or x !== answer.length-1 increase answer by x and return false
	\item Else return true 
	\item Reverse arr
	\item Return answer 
\end{enumerate}

\begin{lstlisting}[title=Solution sortString, captionpos=t]
const sortString = (s) => {
    
    let arr = Array.from(s);
    let result = '';

    arr.sort();
  
    while (arr.length) {
      arr = arr.filter((x, i) => {
        if (i === 0 || x !== result[result.length - 1]) {
          result += x;
          return false;
        }
        return true;
      });
      arr.reverse();
    }
  
    return result;
};
\end{lstlisting}
\medskip %END







\pagebreak %START  
\medskip   
\subsection{Check if All Characters Have Equal Number of Occurrences}
https://leetcode.com/problems/check-if-all-characters-have-equal-number-of-occurrences/

\begin{enumerate}
	\item Initialize empty Map
	\item Loop through letters of s
	\item Map[letter] is equal to itself or zero + 1 (setup count of each letter)
	\item Initialize occurences equal to the set of Object.values(map)
	\item If occurences.size === 1 (all letter groups are equal) return true
	\item Else return false
\end{enumerate}

\begin{lstlisting}[title=Solution areOccurrencesEqual with Map, captionpos=t]
const areOccurrencesEqual = (s) => {
    
    let map = new Map();
    
    for (let letter of s) {
        map[letter] = (map[letter] || 0) + 1;
    }
    
    let count = new Set(Object.values(map));
    if(count.size === 1) return true;
    return false; 
};
\end{lstlisting}

\begin{lstlisting}[title=Solution areOccurrencesEqual with reduce(), captionpos=t]
const areOccurrencesEqualReduce = (s) => {
    
    let count = s.split('').reduce((obj, cur)=>{
      obj.hasOwnProperty(cur) ? obj[cur] += 1 : obj[cur] = 1
      return obj
    },{})

    return new Set(Object.values(count)).size === 1
  };
\end{lstlisting}
\medskip %END




\pagebreak %START  
\medskip   
\subsection{Divide Array Into Equal Pairs}
https://leetcode.com/problems/divide-array-into-equal-pairs/

\begin{enumerate}
	\item Create empty map ()
	\item Loop through nums and if map has number delete it else set the number true
	\item Return true if map size is empty else return false
\end{enumerate}

\begin{lstlisting}[title=Solution divideArray, captionpos=t]
const divideArray = (nums) => {
    
    let map = new Map();
      
    for (const number of nums) {
      map.has(number) ? map.delete(number) : map.set(number, true);
    }
      
    return map.size === 0;
  };
\end{lstlisting}

\medskip %END




\pagebreak %START  
\medskip   
\subsection{N-Repeated Element in Size 2N Array}
https://leetcode.com/problems/n-repeated-element-in-size-2n-array/

\begin{enumerate}
	\item Initialize empty Map()
	\item Loop through values of nums
	\item If value is in map return value
	\item Else return zero 
\end{enumerate}

\begin{lstlisting}[title=Solution repeatedNTimes with Map(), captionpos=t]
const repeatedNTimes = (nums) => {
    
    let map = new Map();
    
    for ( let num of nums) {
        if (num in map) {
            return num;
        } else {
            map[num] = 0;
        }
    }
};
\end{lstlisting}

\begin{lstlisting}[title=Solution repeatedNTimes with ES6, captionpos=t]
var repeatedNTimes = function(nums) {
    return nums.find((a, index, array) => array.indexOf(a) !== index)
};
\end{lstlisting}

\begin{lstlisting}[title=Solution repeatedNTimes with Set(), captionpos=t]
const repeatedNTimes = (A) => {

    let set = new Set();
    
    for(let a of A) {
        if(set.has(a))
            return a;
        
        set.add(a);
    }
};
\end{lstlisting}

\medskip %END







\pagebreak %START  
\medskip   
\subsection{Sum of Unique Elements}
https://leetcode.com/problems/sum-of-unique-elements/

\begin{enumerate}
	\item Create empty Map()
	\item Initialize sum at zero 
	\item Loop through nums if map[n] is undefined increase sum by n and set map[n] to true
	\item Else if decrement n from sum and set map[n] to false 
	\item Return sum 
\end{enumerate}

\begin{lstlisting}[title=Solution sumOfUnique with Map(), captionpos=t]
const sumOfUnique = (nums) => {

    let map = new Map();
    let result = 0;
    
    for (let n of nums) {
        if (map[n] === undefined) {
            result += n;
            map[n] = true;
        } else if(map[n]){
            result -= n;
            map[n] = false;
        }
    }
    
    return result;
};
\end{lstlisting}

\begin{lstlisting}[title=Solution sumOfUnique with forEach, captionpos=t]
var sumOfUnique = function(nums) {
    let result = []
    nums.forEach(function(e){
        if(nums.indexOf(e)  == nums.lastIndexOf(e)){
            result.push(e)
        } 
    })
    return result.reduce((a,b) => a + b , 0)
}
\end{lstlisting}
\medskip %END








\pagebreak %START  
\medskip   
\subsection{Maximum Number of Balls in a Box}
https://leetcode.com/problems/maximum-number-of-balls-in-a-box/

\begin{enumerate}
	\item Create empty Map()
	\item Loop from low to high limit incrementing i and setting sum to zero
	\item Loop through i with j using Math.trunc for the numbers that are more digits
	\item Map.set the numbers so the map is counting the values
	\item Return with math.max the map of split map with the highest values
\end{enumerate}

\begin{lstlisting}[title=Solution countBalls, captionpos=t]
const countBalls = (lowLimit, highLimit) => {
     
    let map = new Map();
       
    for (let i = lowLimit, sum = 0; i <= highLimit; i++, sum = 0) {
      for (let j = i; j; j = Math.trunc(j / 10)) {
          sum += j % 10;
      }
      map.set(sum, (map.get(sum) || 0) + 1);
    }
  
    return Math.max(...map.values());
};
\end{lstlisting}
\medskip %END




\pagebreak %START  
\medskip   
\subsection{Check if Number Has Equal Digit Count and Digit Value}
https://leetcode.com/problems/check-if-number-has-equal-digit-count-and-digit-value/

\begin{enumerate}
	\item Create array with num length and fill it with zero 
	\item For of Loop through num and increase arr[Number(i)++]
	\item return arr.join('') if it is equal to num 
\end{enumerate}

\begin{lstlisting}[title=Solution digitCount, captionpos=t]
const digitCount = (num) => {
    
    let arr= Array(num.length).fill(0);

    for (let i of num) {
        arr[Number(i)]++;
    }
    
    return arr.join('') === num;
};
\end{lstlisting}
\medskip %END




\pagebreak %START  
\medskip   
\subsection{Keep Multiplying Found Values by Two}
https://leetcode.com/problems/keep-multiplying-found-values-by-two/submissions/

\begin{enumerate}
	\item Loop through nums
	\item If nums includes original value multiply original by two 
	\item Return original
\end{enumerate}

\begin{lstlisting}[title=Solution findFinalValue with while loop, captionpos=t]
const findFinalValue = (nums, original) => {

    while (nums.includes(original)) {
        original = original * 2;
    }

    return original;
};
\end{lstlisting}


\begin{lstlisting}[title=Solution findFinalValue with for loop, captionpos=t]
const findFinalValue = (nums, original) => {
        
    for(let i = 0; i<nums.length; i++){
        if(nums.includes(original)){
           original = original * 2
        }
    }
    
    return original
};
\end{lstlisting}

\begin{lstlisting}[title=Solution findFinalValue with set, captionpos=t]
var findFinalValueSet = function(nums, original) {

    const set = new Set(nums)
    let result = original
    
    while (set.has(result))
        result *= 2

    return result
};
\end{lstlisting}

\medskip %END







\pagebreak %START  
\medskip   
\subsection{Two Out of Three}
https://leetcode.com/problems/two-out-of-three/

\begin{enumerate}
	\item Initialize arr with three split... Set() for nums1,2,3
	\item Initialize map object
	\item Initialize empty results array
	\item For of loop through arr and build map to have count of each value
	\item For in loop through map and push any values >= 2 into the results array
	\item Return results
\end{enumerate}

\begin{lstlisting}[title=Solution twoOutOfThree O(n) time/space, captionpos=t]
const twoOutOfThree = (nums1, nums2, nums3) => {
    
    let arr = [...new Set(nums1), ...new Set(nums2), ...new Set(nums3)];
    let map = new Map;
    let result = [];
    
    for(let n of arr) {
        if(map[n]) {
            map[n] += 1;
        } else {
            map[n] = 1;
        }
    }
    
    for(let i in map) {
        if(map[i] >= 2) {
            result.push(i);
        }
    }
    
  return result;
};
\end{lstlisting}


\begin{lstlisting}[title=Solution twoOutOfThree - clunky first answer, captionpos=t]
const twoOutOfThree = (nums1, nums2, nums3) => {
    
    let result = [];
    
    for(let n of nums1){
        for(let n2 of nums2){
            if(n === n2){
                result.push(n);
            }
            for(let n3 of nums3){
                if (n2 === n3){
                    result.push(n2);
                }
                if (n === n3){
                    result.push(n3);
                }
            }
        }
    }
    
    let finalResult = [...new Set(result)];
    return finalResult;
};
\end{lstlisting}
\medskip %END








\pagebreak %START  
\medskip   
\subsection{Kth Distinct String in an Array}
https://leetcode.com/problems/kth-distinct-string-in-an-array/
\begin{enumerate}
	\item Initialize empty map 
	\item Initialize answer array 
	\item For each through the array to build the map
	\item For loop through [key, val] of map Object 
	\item Return the values === 1 and push their key to the answer
	\item Return answer [k-1] since it starts at zero index || empty string if nothing
\end{enumerate}

\begin{lstlisting}[title=Solution kthDistinct, captionpos=t]
const kthDistinct = (arr, k) => {
    
    let map = new Map;
    let result = [];
    
    arr.forEach(i => map[i] = map[i] + 1 || 1);
    
    for (let [key, val] of Object.entries(map)) 
        if (val === 1) result.push(key);
    
    return result[k-1] || "";
};
\end{lstlisting}

\medskip %END







\pagebreak %START  
\medskip   
\subsection{Maximum Number of Words You Can Type}
https://leetcode.com/problems/maximum-number-of-words-you-can-type/

\begin{enumerate}
	\item Initialize empty answer variable
	\item Set t = true 
	\item Create new Set with brokenLetter split into characters
	\item Loop through text and set letter to charAt(i)
	\item If set has letter set t to false 
	\item If letter is empty or letter is there increase by one, set t to true again
	\item If t is there, increase answer by 1	
	\item Return answer
\end{enumerate}

\begin{lstlisting}[title=Solution canBeTypedWords, captionpos=t]
const canBeTypedWords = (text, brokenLetters) => {

    let result = 0;
    let t = true;
    let set = new Set(brokenLetters.split(''));
    
    for(let i=0;i<text.length;i++){
        let letter = text.charAt(i);
        if(set.has(letter)) t = false;
        if(letter==' ') {
            if(t) result += 1;
            t = true;
        }
    }
    
    if(t) result += 1;
    
    return result;
};
\end{lstlisting}

\medskip %END










\pagebreak %START  
\medskip   
\subsection{Substrings of Size Three with Distinct Characters}
https://leetcode.com/problems/substrings-of-size-three-with-distinct-characters/

\begin{enumerate}
	\item Initialize answer at zero 
	\item For loop through s.length  - 1
	\item Set str to  a slice of s that starts at i and goes till i+3
	\item Make a new Set(str)
	\item If the size of the set is === 3, += 1 to answer
	\item Return answer
\end{enumerate}

\begin{lstlisting}[title=Solution countGoodSubstrings, captionpos=t]
const countGoodSubstrings = (s) => {

    let result = 0;

    for (let i = 0; i < s.length - 2; i++) {
        let str = s.slice(i, i + 3);
        let set = new Set(str);
        if (set.size === 3) result += 1;
    }

    return result;
};

\end{lstlisting}

\medskip %END











\pagebreak %START  
\medskip   
\subsection{Find the Difference of Two Arrays}
https://leetcode.com/problems/find-the-difference-of-two-arrays/submissions/

\begin{enumerate}
	\item Set set1 to a new Set of nums1
	\item Set set2 to a new Set of nums2
	\item ForEach loop through nums2 where it will delete any values that are also in set1
	\item ForEach loop through nums1 where it will delete any values that are also in set2
	\item Return and array of split arrays set1 and set2
\end{enumerate}

\begin{lstlisting}[title=Solution findDifference, captionpos=t]
const findDifference = (nums1, nums2) => {
    
    let set1 = new Set(nums1);
    let set2 = new Set(nums2);

    nums2.forEach(i => {set1.delete(i)});
    nums1.forEach(i => {set2.delete(i)});

    return ([[...set1], [...set2]]);
};
\end{lstlisting}

\medskip %END








\pagebreak %START  
\medskip   
\subsection{Isomorphic Strings}
https://leetcode.com/problems/isomorphic-strings/

\begin{enumerate}
	\item Initialize new Map()
	\item Loop through s.length 
	\item If there is no map['s' +s[i]] then add it and set to t[i]
	\item If there is no map['t' +t[i]] then add it and set to s[i]
	\item If t[i] is not equal to the s map or if s[i] is not equal to the t map return false 
	\item Return true
\end{enumerate}

\begin{lstlisting}[title=Solution isIsomorphic, captionpos=t]
const isIsomorphic = (s, t) => {
    
    let map = new Map();

    for (let i = 0; i<s.length; i++){
        if(!map['s' + s[i]]) {
            map['s' + s[i]] = t[i];
        } 
        if(!map['t' + t[i]]) {
            map['t' + t[i]] = s[i];
        }
        if(t[i] != map['s' + s[i]] || s[i] != map['t' + t[i]]){  
            return false;
        } 
    }
    
    return true;
};
\end{lstlisting}

\medskip %END











\pagebreak %START  
\medskip   
\subsection{Word Pattern}
https://leetcode.com/problems/word-pattern/

\begin{enumerate}
	\item Set words to s.split(' ')
	\item Set map to new Map()
	\item If words.length is not equal to pattern return false (catches diff length)
	\item If words.size is not equal to set(patter).size return false (catches equal word)
	\item For loop through pattern length 
	\item If map pattern has pattern [i] and it is not equal to words[i] return false
	\item Map.set pattern[i]  and words[i]
	\item Return true
\end{enumerate}

\begin{lstlisting}[title=Solution wordPattern, captionpos=t]
const wordPattern = (pattern, s) => {
    
    let words = s.split(' ');
    let map = new Map();
    
    if(words.length !== pattern.length){
        return false;
    }
    if(new Set(words).size !== new Set(pattern).size){
        return false;
    } 
    
    for(let i = 0; i < pattern.length; i++) {
        if(map.has(pattern[i]) && 
           map.get(pattern[i]) !== words[i]) {
            return false;
        } 
        map.set(pattern[i], words[i]);
    }
    
    return true;
};
\end{lstlisting}
\medskip %END













\pagebreak %START  
\medskip   
\subsection{Longest Harmonious Subsequence}
https://leetcode.com/problems/longest-harmonious-subsequence/

\begin{enumerate}
	\item Initialize new Map()
	\item Set result at zero 
	\item For of loop through nums map[v] = map[v] + 1 or 1 (build map)
	\item Loop through the key of map and parse int key + 1
	\item Set result to math max result, map[key] + map[parseInt(key) + 1]
	\item Return result
	
\end{enumerate}

\begin{lstlisting}[title=Solution findLHS, captionpos=t]
const findLHS = (nums) => {
    
    let map = new Map(); 
    let result = 0;
    
    for(let v of nums) {
        map[v] = map[v] + 1 || 1;
    }
    
    for (let key in map) {
        if(map[parseInt(key) + 1]) {
            result = Math.max(result, map[key] + map[parseInt(key) + 1]);
        }
    }
    
    return result;
};
\end{lstlisting}

\medskip %END





\pagebreak %START  
\medskip   
\subsection{Next Greater Element I}
https://leetcode.com/problems/next-greater-element-i/

\begin{enumerate}
	\item Initialize new Map()
	\item Initialize empty array called stack 
	\item Loop through nums2 with forEach and nest a while loop
	\item While stack.length  0 \&\& it is within stack push stack n 
	\item Return nums1.map(n map[n] or -1)
\end{enumerate}

\begin{lstlisting}[title=Solution nextGreaterElement, captionpos=t]
const nextGreaterElement = (nums1, nums2) => {
    
    let map = {};
    let stack = [];
      
    nums2.forEach(n => {
      while (stack.length > 0 && stack[stack.length - 1] < n) {
        map[stack.pop()] = n;
      }
      stack.push(n);
    })
      
    return nums1.map(n => map[n] || -1);
  };
\end{lstlisting}

\medskip %END




%END OF SECTION - HASH TABLES








%START OF SECTION - DYNAMIC PROGRAMMING

\pagebreak
\section{Dynamic Programming}



 %START  
\medskip   
\subsection{Counting Bits}
https://leetcode.com/problems/counting-bits/

\begin{enumerate}
	\item Initialize result array at [0]
	\item Initialize offset at 1
	\item For loop through n starting at 1, going till n+1
	\item If offset * 2 === i then set offset to i 
	\item result[i] is equal to 1 + result [i - offset]
	\item Return result
\end{enumerate}

\begin{lstlisting}[title=Solution countBits, captionpos=t]
const countBits = (n) => {
    
    let result = [0];
    let offset = 1;
      
    for (let i = 1; i < n + 1; i++) {
      if (offset * 2 === i) {
        offset = i;
      }
      result[i] = 1 + result[i - offset];
    }
  
    return result;
  };
  \end{lstlisting}

\medskip %END







\pagebreak %START  
\medskip   
\subsection{Fibonacci Number}
https://leetcode.com/problems/fibonacci-number/

\begin{enumerate}
	\item Initialize result to [0,1]
	\item For loop starting from 2 till i <= n
	\item Result push result[i-2] plus result[i-1]
	\item Return result[n]
\end{enumerate}

\begin{lstlisting}[title=Solution fib, captionpos=t]
const fib = (n) => {
    
    let result = [0,1];
    
    for(let i = 2; i<= n; i++){
        result.push(result[i-1] + result[i-2]);
    }
    
    return result[n];
};
\end{lstlisting}
\medskip %END







\pagebreak %START  
\medskip   
\subsection{Pascal's Triangle}
https://leetcode.com/problems/pascals-triangle/

\begin{enumerate}
	\item Initialize empty results array
	\item For loop through n 
	\item Set result[i] to empty array 
	\item Set result[i][0] equal to result[i][i] = 1
	\item For loop through i starting at 1
	\item Set result[i][j] equal to result[i-1][j] + result[i-1][j-1]
	\item Return result
\end{enumerate}

\begin{lstlisting}[title=Solution generate, captionpos=t]
const generate = (n) => {
    
    let result = [];
    
    for (let i = 0; i<n; i++) {
        result[i] = [];
        result[i][0] = result[i][i] = 1;
        for (let j = 1; j < i; j++) {
            result[i][j] = result[i-1][j] + result[i-1][j-1];
        }
    }
    
    return result;
};
\end{lstlisting}

\begin{lstlisting}[title=Solution generate with less mess, captionpos=t]
const generate = (n) => {
    
    let r = [];
    
    for (let i =0;i<n; i++) {
        r[i] = [];
        r[i][0] = r[i][i] = 1;
        for (let j = 1; j<i; j++) {
            r[i][j] = r[i-1][j]+r[i-1][j-1];
        }
    } 
    
    return r;
};
\end{lstlisting}
\medskip %END








\pagebreak %START  
\medskip   
\subsection{Divisor Game}
https://leetcode.com/problems/divisor-game/

\begin{enumerate}
	\item return n \% 2 === 0 
\end{enumerate}

\begin{lstlisting}[title=Solution divisorGame, captionpos=t]
const divisorGame = (n) => {

    return n % 2 === 0;
    
};
\end{lstlisting}


\begin{lstlisting}[title=Solution divisorGame, captionpos=t]
const divisorGame = (n) => {
    
    let result = Array(n + 1).fill(false);
    
    for (let i = 2; i <= n; ++i){
        for (let j = Math.floor(Math.sqrt(i)); 1 <= j; --j){
            if (!(i % j) && !result[i - j]){
                result[i] = true;
            }
        }
    }
   
    return result[n];
};
\end{lstlisting}

\medskip %END






\pagebreak %START  
\medskip   
\subsection{N-th Tribonacci Number}
https://leetcode.com/problems/n-th-tribonacci-number/

\begin{enumerate}
	\item return Initialize result array to 0,1,1
	\item For loop through n starting from 3
	\item Set result to result -1,-2-3 for initial values
	\item Return result[n]
\end{enumerate}

\begin{lstlisting}[title=Solution tribonacci, captionpos=t]
const tribonacci = (n) => {
    
    let result = [0,1,1];
    
    for(let i = 3; i<=n; i++) {
        result[i] = result[i-1] + result[i-2] + result[i-3];
    }
    
    return result[n];
};
\end{lstlisting}

\medskip %END






\pagebreak %START  
\medskip   
\subsection{Min Cost Climbing Stairs}
https://leetcode.com/problems/min-cost-climbing-stairs/

\begin{enumerate}
	\item Initialize L array at cost[0]
	\item Initialize R array at cost[1]
	\item Initialize current as empty array
	\item if cost.length === 1 return zero
	\item If cost.length === 2 return math.min(L, R)
	\item Loop through cost starting from 2
	\item Set current to cost[i] + math.min(L, R)
	\item Set L to R
	\item Set R to current
	\item Return Math.min(L, R)
\end{enumerate}

\begin{lstlisting}[title=Solution minCostClimbingStairs, captionpos=t]
const minCostClimbingStairs = (cost) => {

    let L = cost[0];
    let R = cost[1];
    let current = [];
    
    if (cost.length === 1) return 0;
    if (cost.length === 2) return Math.min(L, R);
    
    for (let i = 2; i < cost.length; i++) {
        current = cost[i] + Math.min(L, R);
        L = R;
        R = current;
    }

    return Math.min(L, R);
};
\end{lstlisting}

\medskip %END










\pagebreak %START  
\medskip   
\subsection{Pascal's Triangle II}
https://leetcode.com/problems/pascals-triangle-ii/

\begin{enumerate}
	\item Initialize result as empty array
	\item Loop through row index + 1
	\item Set result[i] to empty array
	\item Result [i][0] = result [i][i] = 1
	\item Loop through i starting from 1
	\item Set result [i][j] to result[i-1][j] + result[i-1][j-1]
	\item Return result[rowIndex]
\end{enumerate}

\begin{lstlisting}[title=Solution getRow, captionpos=t]
const getRow = (rowIndex) => {

    let result = [];
    
    for(let i = 0; i<rowIndex+1; i++){
        result[i] = [];
        result[i][0] = result[i][i] = 1;
        for(let j = 1; j < i; j++){
            result[i][j] = result[i-1][j] + result[i-1][j-1];
        }
    }
    
    return result[rowIndex];
};
\end{lstlisting}

\medskip %END







\pagebreak %START  
\medskip   
\subsection{Best Time to Buy and Sell Stock}
https://leetcode.com/problems/best-time-to-buy-and-sell-stock/

\begin{enumerate}
	\item Initialize profits at zero
	\item Initialize min at prices[0]
	\item Loop through prices starting from index 1 
	\item If min greater than prices[i] set min=prices[i]
	\item Else if prices[i] - min greater than profit set profit = prices[i] - min
	\item Return profit
\end{enumerate}

\begin{lstlisting}[title=Solution maxProfit, captionpos=t]
const maxProfit = (prices) => {
    
    let profit = 0;
    let min = prices[0];
    
    for(let i = 1; i < prices.length; i++) { 
        if(min > prices[i]) {
            min = prices[i];
        } else if(prices[i] - min > profit) {
            profit = prices[i] - min;
        }
    }
    
    return profit;
};
\end{lstlisting}

\medskip %END









\pagebreak %START  
\medskip   
\subsection{Climbing Stairs}
https://leetcode.com/problems/climbing-stairs/

\begin{enumerate}
	\item Initialize result to [0,1,2,3]
	\item For loop through n starting from 4
	\item Set result[i] to result[i-1] + result[i-2]
	\item Return result[n]
\end{enumerate}

\begin{lstlisting}[title=Solution climbStairs, captionpos=t]
const climbStairs = (n) => {

    let result = [0,1,2,3];
    
    for(let i = 4; i <= n; i++){
        result[i] = result[ i - 1] + result[i - 2];
    }
    
    return result[n];
};
\end{lstlisting}

\medskip %END








\pagebreak %START  
\medskip   
\subsection{Is Subsequence}
https://leetcode.com/problems/is-subsequence/

\begin{enumerate}
	\item Initialize results to zero
	\item If s.length is greater than t.length return false
	\item Loop through t.length and if s[result] === t[i] increment result
	\item Return check if result is equal to s.length
\end{enumerate}

\begin{lstlisting}[title=Solution isSubsequence, captionpos=t]
const isSubsequence = (s, t) => {
    
    let result = 0;

    if (s.length > t.length){
        return false;
    } 

    for (let i = 0; i < t.length; i++) {
        if (s[result] === t[i]) {
            result++;
        }
    }

    return result === s.length;
};
\end{lstlisting}

\medskip %END





%END OF SECTION - DYNAMIC PROGRAMMING







%START OF SECTION - DFS


\pagebreak
\section{Depth First Search Problems}





 %START  
\medskip   
\subsection{Maximum Depth of Binary Tree}
https://leetcode.com/problems/maximum-depth-of-binary-tree/

\begin{enumerate}
	\item Check for empty tress with if root is undefined or null and return zero
	\item Return math max of recursive call maxDepth for root left and root right plus one

\end{enumerate}

\begin{lstlisting}[title=Solution maxDepth, captionpos=t]
const maxDepth = (root) => {
    
    if (root === undefined || root === null) {
        return 0;
    }
    
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
};
\end{lstlisting}

\begin{lstlisting}[title=Solution maxDepth bfs, captionpos=t]
const maxDepth = (root) => {
    
    let result = 0;
    
    const bfs = (node, level) => {
        
        if (!node) return;
        if(level > result) result = level; 
        
        bfs(node.left, level +1);
        bfs(node.right, level +1);
    };
    
    bfs(root, 1);
    return result;
};
\end{lstlisting}

\medskip %END




 %START  
\pagebreak
\medskip   
\subsection{Find a Corresponding Node of a Binary Tree in a Clone of That Tree}
https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/

\begin{enumerate}
	\item If !original AND !cloned return false
	\item If original === target return cloned 
	\item Return recursive getTargetCopy(original.left, cloned.left, target)
	\item Or recursive getTargetCopy(original.right, cloned.right, target)
\end{enumerate}

\begin{lstlisting}[title=Solution getTargetCopy, captionpos=t]
const getTargetCopy = (original, cloned, target) => {
    
    if(!original && !cloned) return false;
    if(original === target) return cloned;
    
    return getTargetCopy(original.left, cloned.left, target) || getTargetCopy(original.right, cloned.right, target);
};
\end{lstlisting}

\medskip %END





 %START  
\pagebreak
\medskip   
\subsection{Evaluate Boolean Binary Tree}
https://leetcode.com/problems/evaluate-boolean-binary-tree/

\begin{enumerate}
	\item Create new function dfs (node)
	\item If no node return
	\item If node.val is 0 return false
	\item If node.val is 1 return true
	\item If node.val is 2 result dfs(node.left) || dfs(node.right)
	\item If node.val is 3 result dfs(node.left) AND dfs(node.right)
	\item Return dfs[root]

\end{enumerate}

\begin{lstlisting}[title=Solution evaluateTree, captionpos=t]
const evaluateTree = (root) => {
    
    const dfs = (node) => {
        
        if (!node) return false; 
        if (node.val === 0) return false;
        if (node.val === 1) return true;
        if (node.val === 2) {
            return dfs(node.left) || dfs(node.right);
        } else if(node.val === 3){
            return dfs(node.left) && dfs(node.right);
        }
    };
    
    return dfs(root);
};
\end{lstlisting}

\medskip %END








 %START  
\pagebreak
\medskip   
\subsection{Find All The Lonely Nodes}
https://leetcode.com/problems/find-all-the-lonely-nodes/

\begin{enumerate}
	\item Create new function dfs with (root)
	\item If no root return results 
	\item If no right root and yes left root result.push value of left root
	\item If no left root and yes right root result.push value of right root
	\item Recursive dfs(root.right)
	\item Recursive dfs(root.left)
	\item Call dfs on root
	\item Return result
\end{enumerate}

\begin{lstlisting}[title=Solution getLonelyNodes, captionpos=t]
const getLonelyNodes = (root) => {
    
    let result = [];
    
    const dfs = (root) => {
        
        if (!root) return result; 
        if (!root.right && root.left) {
            result.push(root.left.val);
        }
        if (!root.left && root.right) {
            result.push(root.right.val);
        }
        dfs(root.right);
        dfs(root.left);
    };
    
    dfs(root);
    return result;
};
\end{lstlisting}

\medskip %END










 %START  
\pagebreak
\medskip   
\subsection{Range Sum of BST}
https://leetcode.com/problems/range-sum-of-bst/

\begin{enumerate}
	\item Initialize result as zero
	\item If no root return result 
	\item If root.val is greater than or equal high AND root.val is greater than or equal to low 
	\item Result += root val
	\item If root.val is greater than low add recursive root.left, low, high
	\item If root.val is lower than high add recursive root.right, low, high
	\item Return result
\end{enumerate}

\begin{lstlisting}[title=Solution rangeSumBST, captionpos=t]
const rangeSumBST = (root, low, high) => {
    
    let result = 0;
    
    if(!root) return result;
    if(root.val <= high && root.val >= low){
        result += (root.val);
    }
    if(root.val > low){
        result += rangeSumBST(root.left, low, high);
    }
    if(root.val < high){
        result += rangeSumBST(root.right, low, high);
    }
    
    return result; 
};
\end{lstlisting}

\medskip %END












 %START  
\pagebreak
\medskip   
\subsection{Sum of Root To Leaf Binary Numbers}
https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/

\begin{enumerate}
	\item Start bfs function with (root, string)
	\item If no root return zero 
	\item String += root.val
	\item If no right and left root return parseInt(string, 2)
	\item Return dfs(root.right, string) + dfs(root.left, string)
	\item Return dfs(root, '')
\end{enumerate}

\begin{lstlisting}[title=Solution sumRootToLeaf, captionpos=t]
const sumRootToLeaf = (root) => {
    
    const dfs = (root, string) => {
        
        if (!root) return 0;
        string += root.val;
        if (!root.right && !root.left) {
            return parseInt(string, 2);
        }
        
        return dfs(root.right, string) + dfs(root.left, string);
    };
    
    return dfs(root, ' ');
};
\end{lstlisting}

\medskip %END
















 %START  
\pagebreak
\medskip   
\subsection{N-ary Tree Preorder Traversal}
https://leetcode.com/problems/n-ary-tree-preorder-traversal/

\begin{enumerate}
	\item Initialize result as [] in function arguments
	\item If !root return results 
	\item Push root.val into results array
	\item For of loop through child of root.children
	\item Recursive call to preorder(child, result) in loop
	\item Return results
\end{enumerate}



\begin{lstlisting}[title=Solution preorder recursive, captionpos=t]
const preorder = (root, result = []) => {
    
    if (!root) return result;
    result.push(root.val);
    
    for (let child of root.children){
        preorder(child, result);
    }
    
    return result;
};
\end{lstlisting}



\begin{lstlisting}[title=Solution preorderIterative, captionpos=t]
const preorderIterative = (root) => {

    let stack = [];
    let result = [];

    if (!root) {
        return result;
    }
    stack.push(root);

    while(stack.length) {
        let node = stack.pop();
        result.push(node.val);
        for(let i = node.children.length - 1; i >= 0; i--) {
            stack.push(node.children[i]);
        }
    }

    return result;
};
\end{lstlisting}

\medskip %END










 %START  
\pagebreak
\medskip   
\subsection{N-ary Tree Postorder Traversal}
https://leetcode.com/problems/n-ary-tree-postorder-traversal/

\begin{enumerate}
	\item Initialize result as empty array
	\item Recurse(root) and return result
	\item Create recurse function with (node)
	\item If no node return result
	\item Loop through child of node.children 
	\item Recurse child
	\item Push node.val into results
\end{enumerate}

\begin{lstlisting}[title=Solution postorder, captionpos=t]
const postorder = (root) => {

    let result = [];

    recurse(root);
    return result;

    function recurse(node) {
        
        if (!node) return result;
        for (let child of node.children) {
            recurse(child);
        }
        result.push(node.val);
    }
};
\end{lstlisting}

\medskip %END









 %START  
\pagebreak
\medskip   
\subsection {Increasing Order Search Tree}
https://leetcode.com/problems/increasing-order-search-tree/

\begin{enumerate}
	\item Initialize null result variable
	\item Initialize null newTree variable
	\item Make new recurse function with node variable
	\item If !node return result 
	\item If no result result = newTree = node
	\item Else newTree.left = null, newTree.right = node, newTree = newTree.right;
	\item Call recurse on (node.right)
	\item Call recurse on (root)
	\item Return result 
\end{enumerate}

\begin{lstlisting}[title=Solution increasingBST, captionpos=t]
const increasingBST = (root) => {
    
    let result = null;
    let newTree = null;
    
    const recurse = (node) => {
        
        if (!node) return result;
        recurse (node.left);
        if (!result) {
            result = newTree = node;
        } else {
            node.left = null;
            newTree.right = node;
            newTree = newTree.right;
        }
        recurse (node.right);
    };

    recurse (root);
    return result;
};
\end{lstlisting}

\medskip %END












 %START  
\pagebreak
\medskip   
\subsection {Merge Two Binary Trees}
https://leetcode.com/problems/merge-two-binary-trees/

\begin{enumerate}
	\item If no root1 return root2, if no root2 return root1
	\item Root1.val += root2.val
	\item Root1.left = recusive call mergeTrees(root1.left, root2.left)
	\item Root1.right = mergeTrees(root1.right, root2.right)
	\item Return root1 
\end{enumerate}

\begin{lstlisting}[title=Solution mergeTrees, captionpos=t]
const mergeTrees = (root1, root2) => {
    
    if (!root1){
        return root2;
    }
    if(!root2){
        return root1;
    }
    
    root1.val += root2.val;
    root1.left = mergeTrees(root1.left, root2.left);
    root1.right = mergeTrees(root1.right, root2.right);
    
    return root1; 
};
\end{lstlisting}

\medskip %END






%END OF SECTION - DFS







%START OF SECTION - BFS

\pagebreak
\section{Breadth First Search}








 %START  
\medskip   
\subsection {Invert Binary Tree}
https://leetcode.com/problems/invert-binary-tree/

\begin{enumerate}
	\item Initialize queue as [root]
	\item While queue.length let n = queue.shift()
	\item If n != null [n.left, n.right] = [n.right, n.left]
	\item Queue.push(n.left, n.right);
	\item Return root
\end{enumerate}

\begin{lstlisting}[title=Solution mergeTrees, captionpos=t]
const invertTree = (root) => {
    
    let queue = [root];
    
    while (queue.length) {
        
        let n = queue.shift();
        
        if(n !== null){
            [n.left, n.right] = [n.right, n.left];
            queue.push(n.left, n.right);
        }
    };
    
    return root;
};
\end{lstlisting}

\medskip %END













 %START  
\pagebreak
\medskip   
\subsection {Maximum Depth of N-ary Tree}
https://leetcode.com/problems/maximum-depth-of-n-ary-tree/

\begin{enumerate}
	\item Initialize result at 0
	\item Initialize queue as empty array
	\item If !root return result
	\item Queue.push(root)
	\item While queue.length let n = queue.length
	\item For loop where i less than n 
	\item Let node = queue.shift()
	\item Push ...node.children into queue
	\item Result++ 
	\item Return result
\end{enumerate}

\begin{lstlisting}[title=Solution maxDepth, captionpos=t]
const maxDepth = (root) => {
    
    let result = 0;
    let queue = [];
    
    if(!root) return result;
    queue.push(root);
    
    while(queue.length){
        
        let n = queue.length;
        
        for(let i = 0; i<n; i++){
            let node = queue.shift();
            queue.push(...node.children);
        }
        result++;
    }
    
    return result;
};
\end{lstlisting}

\medskip %END













 %START  
\pagebreak
\medskip   
\subsection {Island Perimeter}
https://leetcode.com/problems/island-perimeter/submissions/

\begin{enumerate}
	\item Initialize result as zero. Initialize rows as grid.length. Initialize cols as grid[0].length
	\item For loop through rows with row. For loop through cols with col
	\item If !grid[row][col] continue
	\item Result += 4
	\item If row GREATERTHAN 0 AND grid[row-1][col] result --
	\item If col GREATERTHAN 0 AND grid[row][col - 1] result --
	\item If row LESSTHAN rows - 1 AND grid[row+1][col] result --
	\item if col LESSTHAN cols -1 AND grid[row][col+1] result --
	\item Return result
\end{enumerate}

\begin{lstlisting}[title=Solution islandPerimeter, captionpos=t]
const islandPerimeter = (grid) => {
    
    let result = 0;
    let rows = grid.length;
    let cols = grid[0].length;
    
    for(let row = 0; row < rows; row++){
        for(let col = 0; col < cols; col++){
            
            if(!grid[row][col]) continue;
            result += 4;
            
            if(row > 0 && grid[row - 1][col]) result--;
            if(col > 0 && grid[row][col - 1]) result--;
            if(row < rows - 1 && grid[row + 1][col]) result--;
            if(col < cols - 1 && grid[row][col + 1]) result--;
        }
    }
    
    return result
};
\end{lstlisting}

\medskip %END










 %START  
\pagebreak
\medskip   
\subsection {Average of Levels in Binary Tree}
https://leetcode.com/problems/average-of-levels-in-binary-tree/

\begin{enumerate}
	\item Initialize results array 
	\item Initialize node at [root]
	\item While node.length
	\item Let nodeLength = node.length and row = 0
	\item For loop through nodeLength 
	\item Let n = node.shift(); row+= n.val
	\item If n.left node.push(n.left)
	\item If n.right node.push(n.right)
	\item Result.push row/nodeLength
	\item Return result
\end{enumerate}

\begin{lstlisting}[title=Solution averageOfLevels, captionpos=t]
const averageOfLevels = (root) => {
    
    let result = [];
    let node = [root];
    
    while (node.length) {
        let nodeLength = node.length; 
        let row = 0; 
        for (let i = 0; i < nodeLength; i++) {
            let n = node.shift();
            row += n.val;
            if (n.left) node.push(n.left);
            if (n.right) node.push(n.right);
        }
        result.push(row/nodeLength);
    }
    
    return result;
};
\end{lstlisting}

\medskip %END











 %START  
\pagebreak
\medskip   
\subsection {Univalued Binary Tree}
https://leetcode.com/problems/univalued-binary-tree/

\begin{enumerate}
	\item Initialize queue as empty array
	\item Queue.push(root)
	\item While queue.length !== 0
	\item Let n = queue.shift()
	\item If n.val not equal to root.val return false
	\item If n.left queue.push n.left
	\item If n.right queue.push n.right
	\item Return true
\end{enumerate}

\begin{lstlisting}[title=Solution isUnivalTree, captionpos=t]
const isUnivalTree = (root) => {
    
    let queue = [];
    queue.push(root);
    
    while(queue.length !== 0) {
        let n = queue.shift();
        
        if(n.val !== root.val) return false;
        if(n.left) queue.push(n.left);
        if(n.right) queue.push(n.right);
    };    
    
    return true;
};
\end{lstlisting}

\medskip %END
















 %START  
\pagebreak
\medskip   
\subsection {Flood Fill}
https://leetcode.com/problems/flood-fill/

\begin{enumerate}
	\item Initialize currColor as image[sr][sc]
	\item Initialize queue as [[sr,sc]];
	\item if currColor === color return image 
	\item While queue.length let [row,col] = queue.shift()
	\item If image[row][col] === currColor update them to color
	\item UP If row - greaterthan or equal to 0 queue.push row-1,col 
	\item DOWN If row + 1 less than image.length queue push row + 1, col
	\item RIGHT If col + 1 less than image[0].length queue push row, col +1
	\item LEFT if col - 1 greater than or equal to zero queue.push row, col-1
	\item Return image

\end{enumerate}

\begin{lstlisting}[title=Solution floodFill, captionpos=t]
const floodFill = (image, sr, sc, color) => {
    
    let currColor = image[sr][sc];
    let queue = [[sr, sc]];
    
    if(currColor === color) return image;
    
    while(queue.length !== 0){
        
        let [row, col] = queue.shift();
        
        if(image[row][col] === currColor){
            image[row][col] = color;
            if(row - 1 >= 0) queue.push([row-1, col]); 
            //up
            if(row + 1 < image.length) queue.push([row + 1, col]);
            //down
            if(col + 1 < image[0].length) queue.push([row, col+1]);
            //right
            if(col -1 >=0) queue.push([row, col-1]);
            //left
        }        
    }
    
    return image;
};
\end{lstlisting}

\medskip %END










 %START  
\pagebreak
\medskip   
\subsection {Two Sum IV - Input is a BST}
https://leetcode.com/problems/two-sum-iv-input-is-a-bst/

\begin{enumerate}
	\item Initialize set as a new set
	\item Initialize queue as [root]
	\item While queue.length !== 0
	\item let n = queue.shift()
	\item If set has(k-n.val) return true
	\item Set.add(n.val)
	\item If(n.left) queue push n.left
	\item If n.right queue.push n.right
	\item Return false
\end{enumerate}

\begin{lstlisting}[title=Solution findTarget, captionpos=t]
const findTarget = (root, k) => {
    
    let set = new Set();
    let queue = [root];
    
    while(queue.length) {
        let n = queue.shift();
        if(set.has(k - n.val)) return true;
        set.add(n.val);
        if(n.left) queue.push(n.left);
        if(n.right) queue.push(n.right);
    }
    
    return false;
};
\end{lstlisting}

\medskip %END















 %START  
\pagebreak
\medskip   
\subsection {Minimum Absolute Difference in BST}
https://leetcode.com/problems/minimum-absolute-difference-in-bst/

\begin{enumerate}
	\item Initialize result as Infinity
	\item Initialize prev as -Infinity
	\item Build recursive with (node) and return if node is empty
	\item Recursive call on node.left 
	\item Result = Math.min(result, node.val -prev)
	\item Prev = node.val
	\item Recursive call on node.right
	\item Recursive call on (root)
	\item Return result
\end{enumerate}

\begin{lstlisting}[title=Solution getMinimumDifference, captionpos=t]
const getMinimumDifference = (root) => {
    
    let result = Infinity;
    let prev = -Infinity;
    
    const recursive = (node) => {
    
        if(!node) return result;
        
        recursive(node.left);
        result = Math.min(result, node.val - prev);
        prev = node.val;
        recursive(node.right);
    };
    
    recursive(root);
    return result;
};
\end{lstlisting}

\medskip %END











 %START  
\pagebreak
\medskip   
\subsection {Minimum Distance Between BST Nodes}
https://leetcode.com/problems/minimum-distance-between-bst-nodes/submissions/

\begin{lstlisting}[title=Solution minDiffInBST, captionpos=t]
const minDiffInBST = (root) => {
    let prev = null;
    let result = Infinity;
    
    const recursive = (node) => {
        if (!node) return;
        recursive(node.left);
        if (prev) {
            result = Math.min(result, Math.abs(node.val - prev.val));
        }
        prev = node;
        recursive(node.right);
    };
    
    recursive(root);
    return result;
};
\end{lstlisting}


\begin{lstlisting}[title=Solution minDiffInBST Iterative, captionpos=t]
const minDiffInBST = root => {
    
    const stack = [];
    let curr = root, prev = null, min = Infinity;
    
    while (stack.length || curr) {
        if (curr) {
            stack.push(curr);
            curr = curr.left;
        } else {
            curr = stack.pop();
            if (prev) {
                min = Math.min(min, Math.abs(curr.val - prev.val))
            }
            prev = curr;		
            curr = curr.right;
        }
    }
    
    return min;
};\end{lstlisting}

\medskip %END






 %START  
\pagebreak
\medskip   
\subsection {Same Tree}
https://leetcode.com/problems/same-tree/

\begin{enumerate}
	\item If no p and q return true
	\item if no p or queue, or p.val is not equal to q.val return false
	\item Return recursive isSameTree(p.left and q.left) AND isSameTree(p.right and q.right)
\end{enumerate}

\begin{lstlisting}[title=Solution isSameTree, captionpos=t]
const isSameTree = (p, q) => {

    if (!p && !q) return true;
    if (!p || !q || p.val !== q.val) {
        return false;    
    }

    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
};
\end{lstlisting}

\medskip %END






%END OF SECTION - BFS







%START OF SECTION - BST

\pagebreak
\section{Binary Search Tree}








 %START  
\medskip   
\subsection {Search in a Binary Search Tree}
https://leetcode.com/problems/search-in-a-binary-search-tree/

\begin{enumerate}
	\item Initialize result as null 
	\item Build recursive const with (node) as argument
	\item If no node return result 
	\item If node.val is equal to val, result = node and return result
	\item If val lessthan node.val recursive node.left
	\item if val greaterthan node.val recursive node.right
	\item Recursive through root and return result
\end{enumerate}

\begin{lstlisting}[title=Solution searchBST, captionpos=t]
const searchBST = (root, val) => {
    
    let result = null; 
    
    const recursive = (node) => {
        
        if(!node) return result; 
        if(node.val === val){
            result = node;
            return result;
        }
        if(val < node.val) recursive(node.left);
        if(val > node.val) recursive(node.right);
    };

    recursive(root);
    return result;
};
\end{lstlisting}

\medskip %END















 %START  
\pagebreak
\medskip   
\subsection {Convert Sorted Array to Binary Search Tree}
https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/

\begin{enumerate}
	\item  
	\item 
\end{enumerate}

\begin{lstlisting}[title=Solution sortedArrayToBST, captionpos=t]
const sortedArrayToBST = (nums) => {
    
    if (!nums) return null;
    
    const recursive = (low, high) => {
        
        let mid = Math.floor((low + high) / 2);
        let root = new TreeNode(nums[mid]);
        
        if(low > high) return null;
        
        root.left = recursive(low, mid - 1);
        root.right = recursive(mid + 1, high);
        
        return root;
    };
    
    return recursive(0, nums.length - 1);
};
\end{lstlisting}

\medskip %END





 %START  
\pagebreak
\medskip   
\subsection {Unique Binary Search Trees}
https://leetcode.com/problems/unique-binary-search-trees/

\begin{enumerate}
	\item  
	\item 
\end{enumerate}

\begin{lstlisting}[title=Solution numTrees, captionpos=t]
const numTrees = (n) => {
    
    let result = new Array(n + 1).fill(0);
    result[0] = 1;
    result[1] = 1;
    
    for (let i = 2; i <= n; i++){
        for (let j = 1; j <= i; j++){
            result[i] += result[j - 1] * result[i - j];
        }
    }
    
    return result[n];
};
\end{lstlisting}

\medskip %END















 %START  
\pagebreak
\medskip   
\subsection {Lowest Common Ancestor of a Binary Search Tree}
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

\begin{enumerate}
	\item  
	\item 
\end{enumerate}

\begin{lstlisting}[title=Solution lowestCommonAncestor, captionpos=t]
const lowestCommonAncestor = (root, p, q) => {
    
    if(root.val > p.val && root.val > q.val) {
        return lowestCommonAncestor(root.left, p, q);
    }
    
    if(root.val < p.val && root.val < q.val) {
        return lowestCommonAncestor(root.right, p, q);
    }
    
    return root;
};
\end{lstlisting}

\medskip %END

















 %START  
\pagebreak
\medskip   
\subsection {Closest Binary Search Tree Value}
https://leetcode.com/problems/closest-binary-search-tree-value/

\begin{enumerate}
	\item  
	\item 
\end{enumerate}

\begin{lstlisting}[title=Solution closestValue, captionpos=t]
const closestValue = (root, target) => {
    
    let child = target < root.val ? root.left : root.right;
    if (!child) return root.val;
    let closest = closestValue(child, target);
    
    return Math.abs(closest - target) < Math.abs(root.val - target) ? closest : root.val;
};
\end{lstlisting}

\medskip %END












 %START  
\pagebreak
\medskip   
\subsection {Binary Search Tree to Greater Sum Tree}
https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/

\begin{enumerate}
	\item  
	\item 
\end{enumerate}

\begin{lstlisting}[title=Solution bstToGst, captionpos=t]
const bstToGst = (root) => {
    
    const getSum = (node, sum) => {
        
        if (!node) return sum;
        node.val += getSum(node.right, sum);
        return getSum(node.left, node.val);
    };
    
    getSum(root, 0);
    return root;
};
\end{lstlisting}

\medskip %END

























 %START  
\pagebreak
\medskip   
\subsection {Construct Binary Search Tree from Preorder Traversal}
https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/

\begin{enumerate}
	\item Construct recursive function with lower, upper 
	\item If preorder[0] less than lower or greaterthan upper return null
	\item If preorder.length === 0 return null 
	\item Initialize root as new TreeNode and shift first item of preorder into it
	\item Set root.left as recursive(lower, root.val)
	\item Set root.right as recursive(root.val, upper)
	\item Return root
	\item Return recursive(-Infinity, Infinity)
\end{enumerate}

\begin{lstlisting}[title=Solution bstFromPreorder, captionpos=t]
const bstFromPreorder = (preorder) => {
    
    const recursive = (lower, upper) => {
        
        if (preorder[0] < lower || preorder[0] > upper) return null;
        if (preorder.length === 0) return null; 
        
        let root = new TreeNode(preorder.shift());
        
        root.left = recursive(lower, root.val);
        root.right = recursive(root.val, upper);
        
        return root;
    };

    return recursive(-Infinity, Infinity);
};
\end{lstlisting}
\medskip %END





















 %START  
\pagebreak
\medskip   
\subsection {Balance a Binary Search Tree}
https://leetcode.com/problems/balance-a-binary-search-tree/

\begin{enumerate}
	\item Initialize builtArray as arrayBuilder(root)
	\item Return bstBuilder(builtArray)
	\item Construct helper arrayBuilder function 
	\item Construct helper bstBuilder function
\end{enumerate}

\begin{lstlisting}[title=Solution balanceBST, captionpos=t]
const balanceBST = (root) => {
    
    let builtArray = arrayBuilder(root);
    
    return bstBuilder(builtArray);
};

const arrayBuilder = (node) => {
    
    if (!node) return [];
    
    return [...arrayBuilder(node.left), node.val, ...arrayBuilder(node.right)];
};

const bstBuilder = (arr) => {
    
    if (arr.length === 0) return null;
    if (arr.length === 1) return new TreeNode(arr);
    
    let mid = Math.floor(arr.length / 2);
    let left = bstBuilder(arr.slice(0, mid));
    let right = bstBuilder(arr.slice(mid + 1));
    
    return new TreeNode(arr[mid], left, right);
};
\end{lstlisting}
\medskip %END


















 %START  
\pagebreak
\medskip   
\subsection {Kth Smallest Element in a BST}
https://leetcode.com/problems/kth-smallest-element-in-a-bst/

\begin{enumerate}
	\item Initialize stack, counter, and node
	\item While true if node stack.push and set node to left
	\item Else if stack is empty continue and increase counter
	\item If counter equal k return node.val otherwise move to node.right

\end{enumerate}

\begin{lstlisting}[title=Solution kthSmallest, captionpos=t]
const kthSmallest = (root, k) => {
    
    let stack = [];
    let counter = 0;
    let node = root;
    
    while (true) {
        if (node) {
            stack.push(node);
            node = node.left;
        } else {
            if (stack.length === 0) break;
            node = stack.pop();
            counter += 1;
            if (counter === k) return node.val;
            node = node.right;
        }
    }
};
\end{lstlisting}
\medskip %END
















 %START  
\pagebreak
\medskip   
\subsection {Delete Node in a BST}
https://leetcode.com/problems/delete-node-in-a-bst/

\begin{enumerate}
	\item 

\end{enumerate}

\begin{lstlisting}[title=Solution deleteNode, captionpos=t]
const deleteNode = (root, key) => {
    
    const callDFS = (node) => {
    
        if (!node) return null;
        if (node.val === key) {
            if (!node.left) return node.right;
            if (!node.right) return node.left;
            let curr = node.right;
            while (curr.left) {
                curr = curr.left;
            }
            curr.left = node.left
            return node.right;
        }
        if (key > node.val) {
            node.right = callDFS(node.right);
        } else {
            node.left = callDFS(node.left);
        }
        
        return node;
    };
    
    return callDFS(root);
};
\end{lstlisting}
\medskip %END










\end{document}
